/*
 * This code was generated by the XML Schema Compiler.
 *
 * Changes made to this code will most likely be overwritten
 * when the handlers are recompiled.
 */
#ifndef BASIC_DEPLOYMENT_DATA_HPP
#define BASIC_DEPLOYMENT_DATA_HPP

#include "xsc_xml_handlers_export.h"
// Forward declarations.
namespace DAnCE
{
  namespace Config_Handlers
  {
    class IdRef;
    class TCKind;
    class DataType;
    class DataValue;
    class AliasType;
    class EnumType;
    class BoundedStringType;
    class StructType;
    class StructMemberType;
    class ValueType;
    class ValueMemberType;
    class NamedValue;
    class ArrayType;
    class SequenceType;
    class Any;
    class Property;
    class SatisfierPropertyKind;
    class SatisfierProperty;
    class Resource;
    class Requirement;
    class ResourceDeploymentDescription;
    class ArtifactDeploymentDescription;
    class MonolithicDeploymentDescription;
    class ResourceUsageKind;
    class InstanceResourceDeploymentDescription;
    class InstanceDeploymentDescription;
    class CCMComponentPortKind;
    class ComponentPortDescription;
    class ComponentPropertyDescription;
    class ComponentExternalPortEndpoint;
    class PlanSubcomponentPortEndpoint;
    class ExternalReferenceEndpoint;
    class ConnectionResourceDeploymentDescription;
    class PlanConnectionDescription;
    class ImplementationDependency;
    class Capability;
    class ImplementationRequirement;
    class SubcomponentPortEndpoint;
    class AssemblyConnectionDescription;
    class PlanLocalityKind;
    class PlanLocality;
  }
}

#include <memory>
#include <string>
#include <vector>
#include "ace/XML_Utils/XMLSchema/Types.hpp"
#include "ace/XML_Utils/XMLSchema/id_map.hpp"
#include "tao/x11/stddef.h"
#include "XMI.hpp"

namespace DAnCE
{
  namespace Config_Handlers
  {
    class XSC_XML_Handlers_Export IdRef : public ::XSCRT::Type
    {
      using Base = ::XSCRT::Type;

      // href
      public:
      bool href_p () const;
      ::XMLSchema::string<char> const& href () const;
      ::XMLSchema::string<char>& href ();
      void href (::XMLSchema::string<char> const& );

      protected:
      using href_unique_ptr_type = std::unique_ptr< ::XMLSchema::string<char>>;
      href_unique_ptr_type href_;

      // idref
      public:
      bool idref_p () const;
      ::XMLSchema::IDREF<char> const& idref () const;
      ::XMLSchema::IDREF<char>& idref ();
      void idref (::XMLSchema::IDREF<char> const& );

      protected:
      using idref_unique_ptr_type = std::unique_ptr< ::XMLSchema::IDREF<char>>;
      idref_unique_ptr_type idref_;

      public:
      IdRef ();

      explicit IdRef (::XSCRT::XML::Element<char> const&);
      IdRef (IdRef const& s);
      IdRef& operator= (IdRef const& s);

      IdRef (IdRef&&) = default;
      IdRef& operator= (IdRef&&) = default;
    };


    class XSC_XML_Handlers_Export TCKind : public ::XSCRT::Type
    {
      public:
      explicit TCKind (::XSCRT::XML::Element<char> const&);
      explicit TCKind (::XSCRT::XML::Attribute<char> const&);

      static TCKind const tk_null;
      static TCKind const tk_void;
      static TCKind const tk_short;
      static TCKind const tk_long;
      static TCKind const tk_ushort;
      static TCKind const tk_ulong;
      static TCKind const tk_float;
      static TCKind const tk_double;
      static TCKind const tk_boolean;
      static TCKind const tk_char;
      static TCKind const tk_octet;
      static TCKind const tk_any;
      static TCKind const tk_TypeCode;
      static TCKind const tk_Principal;
      static TCKind const tk_objref;
      static TCKind const tk_struct;
      static TCKind const tk_union;
      static TCKind const tk_enum;
      static TCKind const tk_string;
      static TCKind const tk_sequence;
      static TCKind const tk_array;
      static TCKind const tk_alias;
      static TCKind const tk_except;
      static TCKind const tk_longlong;
      static TCKind const tk_ulonglong;
      static TCKind const tk_longdouble;
      static TCKind const tk_wchar;
      static TCKind const tk_wstring;
      static TCKind const tk_fixed;
      static TCKind const tk_value;
      static TCKind const tk_value_box;
      static TCKind const tk_native;
      static TCKind const tk_abstract_interface;
      static TCKind const tk_local_interface;
      static TCKind const tk_component;
      static TCKind const tk_home;
      static TCKind const tk_event;

      enum Value
      {
        tk_null_l, tk_void_l, tk_short_l, tk_long_l, tk_ushort_l, tk_ulong_l, tk_float_l, tk_double_l, tk_boolean_l, tk_char_l, tk_octet_l, tk_any_l, tk_TypeCode_l, tk_Principal_l, tk_objref_l, tk_struct_l, tk_union_l, tk_enum_l, tk_string_l, tk_sequence_l, tk_array_l, tk_alias_l, tk_except_l, tk_longlong_l, tk_ulonglong_l, tk_longdouble_l, tk_wchar_l, tk_wstring_l, tk_fixed_l, tk_value_l, tk_value_box_l, tk_native_l, tk_abstract_interface_l, tk_local_interface_l, tk_component_l, tk_home_l, tk_event_l
      };


      Value
      integral () const;

      friend bool XSC_XML_Handlers_Export 
      operator== (TCKind const& a, TCKind const& b);

      friend bool XSC_XML_Handlers_Export 
      operator!= (TCKind const& a, TCKind const& b);

      private:
      TCKind (Value v);

      Value v_;
    };

    bool XSC_XML_Handlers_Export operator== (TCKind const &a, TCKind const &b);

    bool XSC_XML_Handlers_Export operator!= (TCKind const &a, TCKind const &b);


    class XSC_XML_Handlers_Export DataType : public ::XSCRT::Type
    {
      using Base = ::XSCRT::Type;

      // kind
      public:
      ::DAnCE::Config_Handlers::TCKind const& kind () const;
      void kind (::DAnCE::Config_Handlers::TCKind const& );

      protected:
      using kind_unique_ptr_type = std::unique_ptr< ::DAnCE::Config_Handlers::TCKind>;
      kind_unique_ptr_type kind_;

      // enum
      public:
      bool enum_p () const;
      ::DAnCE::Config_Handlers::EnumType const& enum_ () const;
      void enum_ (::DAnCE::Config_Handlers::EnumType const& );

      protected:
      using enum__unique_ptr_type = std::unique_ptr< ::DAnCE::Config_Handlers::EnumType>;
      enum__unique_ptr_type enum__;

      // struct
      public:
      bool struct_p () const;
      ::DAnCE::Config_Handlers::StructType const& struct_ () const;
      void struct_ (::DAnCE::Config_Handlers::StructType const& );

      protected:
      using struct__unique_ptr_type = std::unique_ptr< ::DAnCE::Config_Handlers::StructType>;
      struct__unique_ptr_type struct__;

      // value
      public:
      bool value_p () const;
      ::DAnCE::Config_Handlers::ValueType const& value () const;
      void value (::DAnCE::Config_Handlers::ValueType const& );

      protected:
      using value_unique_ptr_type = std::unique_ptr< ::DAnCE::Config_Handlers::ValueType>;
      value_unique_ptr_type value_;

      // sequence
      public:
      bool sequence_p () const;
      ::DAnCE::Config_Handlers::SequenceType const& sequence () const;
      void sequence (::DAnCE::Config_Handlers::SequenceType const& );

      protected:
      using sequence_unique_ptr_type = std::unique_ptr< ::DAnCE::Config_Handlers::SequenceType>;
      sequence_unique_ptr_type sequence_;

      // alias
      public:
      bool alias_p () const;
      ::DAnCE::Config_Handlers::AliasType const& alias () const;
      void alias (::DAnCE::Config_Handlers::AliasType const& );

      protected:
      using alias_unique_ptr_type = std::unique_ptr< ::DAnCE::Config_Handlers::AliasType>;
      alias_unique_ptr_type alias_;

      // array
      public:
      bool array_p () const;
      ::DAnCE::Config_Handlers::ArrayType const& array () const;
      void array (::DAnCE::Config_Handlers::ArrayType const& );

      protected:
      using array_unique_ptr_type = std::unique_ptr< ::DAnCE::Config_Handlers::ArrayType>;
      array_unique_ptr_type array_;

      // boundedString
      public:
      bool boundedString_p () const;
      ::DAnCE::Config_Handlers::BoundedStringType const& boundedString () const;
      void boundedString (::DAnCE::Config_Handlers::BoundedStringType const& );

      protected:
      using boundedString_unique_ptr_type = std::unique_ptr< ::DAnCE::Config_Handlers::BoundedStringType>;
      boundedString_unique_ptr_type boundedString_;

      // id
      public:
      bool id_p () const;
      ::XMLSchema::ID<char> const& id () const;
      ::XMLSchema::ID<char>& id ();
      void id (::XMLSchema::ID<char> const& );

      protected:
      using id_unique_ptr_type = std::unique_ptr< ::XMLSchema::ID<char>>;
      id_unique_ptr_type id_;

      public:
      DataType (::DAnCE::Config_Handlers::TCKind const& kind__);

      explicit DataType (::XSCRT::XML::Element<char> const&);
      DataType (DataType const& s);
      DataType& operator= (DataType const& s);

      DataType (DataType&&) = default;
      DataType& operator= (DataType&&) = default;
    };


    class XSC_XML_Handlers_Export DataValue : public ::XSCRT::Type
    {
      using Base = ::XSCRT::Type;

      // short
      public:
      using short_container_type = std::vector< ::XMLSchema::short_>;
      using short_const_iterator = short_container_type::const_iterator;
      short_const_iterator begin_short () const;
      short_const_iterator end_short () const;
      size_t count_short () const;

      protected:
      short_container_type short__;

      // long
      public:
      using long_container_type = std::vector< ::XMLSchema::int_>;
      using long_const_iterator = long_container_type::const_iterator;
      long_const_iterator begin_long () const;
      long_const_iterator end_long () const;
      size_t count_long () const;

      protected:
      long_container_type long__;

      // ushort
      public:
      using ushort_container_type = std::vector< ::XMLSchema::unsignedShort>;
      using ushort_const_iterator = ushort_container_type::const_iterator;
      ushort_const_iterator begin_ushort () const;
      ushort_const_iterator end_ushort () const;
      size_t count_ushort () const;

      protected:
      ushort_container_type ushort_;

      // ulong
      public:
      using ulong_container_type = std::vector< ::XMLSchema::unsignedInt>;
      using ulong_const_iterator = ulong_container_type::const_iterator;
      ulong_const_iterator begin_ulong () const;
      ulong_const_iterator end_ulong () const;
      size_t count_ulong () const;

      protected:
      ulong_container_type ulong_;

      // float
      public:
      using float_container_type = std::vector< ::XMLSchema::float_>;
      using float_const_iterator = float_container_type::const_iterator;
      float_const_iterator begin_float () const;
      float_const_iterator end_float () const;
      size_t count_float () const;

      protected:
      float_container_type float__;

      // double
      public:
      using double_container_type = std::vector< ::XMLSchema::double_>;
      using double_const_iterator = double_container_type::const_iterator;
      double_const_iterator begin_double () const;
      double_const_iterator end_double () const;
      size_t count_double () const;

      protected:
      double_container_type double__;

      // boolean
      public:
      using boolean_container_type = std::vector< ::XMLSchema::boolean>;
      using boolean_const_iterator = boolean_container_type::const_iterator;
      boolean_const_iterator begin_boolean () const;
      boolean_const_iterator end_boolean () const;
      size_t count_boolean () const;

      protected:
      boolean_container_type boolean_;

      // octet
      public:
      using octet_container_type = std::vector< ::XMLSchema::unsignedByte>;
      using octet_const_iterator = octet_container_type::const_iterator;
      octet_const_iterator begin_octet () const;
      octet_const_iterator end_octet () const;
      size_t count_octet () const;

      protected:
      octet_container_type octet_;

      // enum
      public:
      using enum_container_type = std::vector< ::XMLSchema::string<char>>;
      using enum_const_iterator = enum_container_type::const_iterator;
      enum_const_iterator begin_enum () const;
      enum_const_iterator end_enum () const;
      size_t count_enum () const;

      protected:
      enum_container_type enum__;

      // string
      public:
      using string_container_type = std::vector< ::XMLSchema::string<char>>;
      using string_const_iterator = string_container_type::const_iterator;
      string_const_iterator begin_string () const;
      string_const_iterator end_string () const;
      size_t count_string () const;

      protected:
      string_container_type string_;

      // longlong
      public:
      using longlong_container_type = std::vector< ::XMLSchema::long_>;
      using longlong_const_iterator = longlong_container_type::const_iterator;
      longlong_const_iterator begin_longlong () const;
      longlong_const_iterator end_longlong () const;
      size_t count_longlong () const;

      protected:
      longlong_container_type longlong_;

      // ulonglong
      public:
      using ulonglong_container_type = std::vector< ::XMLSchema::unsignedLong>;
      using ulonglong_const_iterator = ulonglong_container_type::const_iterator;
      ulonglong_const_iterator begin_ulonglong () const;
      ulonglong_const_iterator end_ulonglong () const;
      size_t count_ulonglong () const;

      protected:
      ulonglong_container_type ulonglong_;

      // longdouble
      public:
      using longdouble_container_type = std::vector< ::XMLSchema::double_>;
      using longdouble_const_iterator = longdouble_container_type::const_iterator;
      longdouble_const_iterator begin_longdouble () const;
      longdouble_const_iterator end_longdouble () const;
      size_t count_longdouble () const;

      protected:
      longdouble_container_type longdouble_;

      // element
      public:
      using element_container_type = std::vector< ::DAnCE::Config_Handlers::DataValue>;
      using element_const_iterator = element_container_type::const_iterator;
      element_const_iterator begin_element () const;
      element_const_iterator end_element () const;
      size_t count_element () const;

      protected:
      element_container_type element_;

      // member
      public:
      using member_container_type = std::vector< ::DAnCE::Config_Handlers::NamedValue>;
      using member_const_iterator = member_container_type::const_iterator;
      member_const_iterator begin_member () const;
      member_const_iterator end_member () const;
      size_t count_member () const;

      protected:
      member_container_type member_;

      public:
      DataValue ();

      explicit DataValue (::XSCRT::XML::Element<char> const&);
      DataValue (DataValue const& s);
      DataValue& operator= (DataValue const& s);

      DataValue (DataValue&&) = default;
      DataValue& operator= (DataValue&&) = default;
    };


    class XSC_XML_Handlers_Export AliasType : public ::XSCRT::Type
    {
      using Base = ::XSCRT::Type;

      // name
      public:
      ::XMLSchema::string<char> const& name () const;
      void name (::XMLSchema::string<char> const& );

      protected:
      using name_unique_ptr_type = std::unique_ptr< ::XMLSchema::string<char>>;
      name_unique_ptr_type name_;

      // typeId
      public:
      ::XMLSchema::string<char> const& typeId () const;
      void typeId (::XMLSchema::string<char> const& );

      protected:
      using typeId_unique_ptr_type = std::unique_ptr< ::XMLSchema::string<char>>;
      typeId_unique_ptr_type typeId_;

      // elementType
      public:
      ::DAnCE::Config_Handlers::DataType const& elementType () const;
      void elementType (::DAnCE::Config_Handlers::DataType const& );

      protected:
      using elementType_unique_ptr_type = std::unique_ptr< ::DAnCE::Config_Handlers::DataType>;
      elementType_unique_ptr_type elementType_;

      public:
      AliasType (::XMLSchema::string<char> const& name__,
                 ::XMLSchema::string<char> const& typeId__,
                 ::DAnCE::Config_Handlers::DataType const& elementType__);

      explicit AliasType (::XSCRT::XML::Element<char> const&);
      AliasType (AliasType const& s);
      AliasType& operator= (AliasType const& s);

      AliasType (AliasType&&) = default;
      AliasType& operator= (AliasType&&) = default;
    };


    class XSC_XML_Handlers_Export EnumType : public ::XSCRT::Type
    {
      using Base = ::XSCRT::Type;

      // name
      public:
      ::XMLSchema::string<char> const& name () const;
      void name (::XMLSchema::string<char> const& );

      protected:
      using name_unique_ptr_type = std::unique_ptr< ::XMLSchema::string<char>>;
      name_unique_ptr_type name_;

      // typeId
      public:
      ::XMLSchema::string<char> const& typeId () const;
      void typeId (::XMLSchema::string<char> const& );

      protected:
      using typeId_unique_ptr_type = std::unique_ptr< ::XMLSchema::string<char>>;
      typeId_unique_ptr_type typeId_;

      // member
      public:
      using member_container_type = std::vector< ::XMLSchema::string<char>>;
      using member_const_iterator = member_container_type::const_iterator;
      member_const_iterator begin_member () const;
      member_const_iterator end_member () const;
      size_t count_member () const;

      protected:
      member_container_type member_;

      public:
      EnumType (::XMLSchema::string<char> const& name__,
                ::XMLSchema::string<char> const& typeId__,
                member_container_type const& member__);

      explicit EnumType (::XSCRT::XML::Element<char> const&);
      EnumType (EnumType const& s);
      EnumType& operator= (EnumType const& s);

      EnumType (EnumType&&) = default;
      EnumType& operator= (EnumType&&) = default;
    };


    class XSC_XML_Handlers_Export BoundedStringType : public ::XSCRT::Type
    {
      using Base = ::XSCRT::Type;

      // bound
      public:
      using bound_container_type = std::vector< ::XMLSchema::unsignedInt>;
      using bound_const_iterator = bound_container_type::const_iterator;
      bound_const_iterator begin_bound () const;
      bound_const_iterator end_bound () const;
      size_t count_bound () const;

      protected:
      bound_container_type bound_;

      public:
      BoundedStringType ();

      explicit BoundedStringType (::XSCRT::XML::Element<char> const&);
      BoundedStringType (BoundedStringType const& s);
      BoundedStringType& operator= (BoundedStringType const& s);

      BoundedStringType (BoundedStringType&&) = default;
      BoundedStringType& operator= (BoundedStringType&&) = default;
    };


    class XSC_XML_Handlers_Export StructType : public ::XSCRT::Type
    {
      using Base = ::XSCRT::Type;

      // name
      public:
      ::XMLSchema::string<char> const& name () const;
      void name (::XMLSchema::string<char> const& );

      protected:
      using name_unique_ptr_type = std::unique_ptr< ::XMLSchema::string<char>>;
      name_unique_ptr_type name_;

      // typeId
      public:
      ::XMLSchema::string<char> const& typeId () const;
      void typeId (::XMLSchema::string<char> const& );

      protected:
      using typeId_unique_ptr_type = std::unique_ptr< ::XMLSchema::string<char>>;
      typeId_unique_ptr_type typeId_;

      // member
      public:
      using member_container_type = std::vector< ::DAnCE::Config_Handlers::StructMemberType>;
      using member_const_iterator = member_container_type::const_iterator;
      member_const_iterator begin_member () const;
      member_const_iterator end_member () const;
      size_t count_member () const;

      protected:
      member_container_type member_;

      public:
      StructType (::XMLSchema::string<char> const& name__,
                  ::XMLSchema::string<char> const& typeId__);

      explicit StructType (::XSCRT::XML::Element<char> const&);
      StructType (StructType const& s);
      StructType& operator= (StructType const& s);

      StructType (StructType&&) = default;
      StructType& operator= (StructType&&) = default;
    };


    class XSC_XML_Handlers_Export StructMemberType : public ::XSCRT::Type
    {
      using Base = ::XSCRT::Type;

      // name
      public:
      ::XMLSchema::string<char> const& name () const;
      void name (::XMLSchema::string<char> const& );

      protected:
      using name_unique_ptr_type = std::unique_ptr< ::XMLSchema::string<char>>;
      name_unique_ptr_type name_;

      // type
      public:
      ::DAnCE::Config_Handlers::DataType const& type () const;
      void type (::DAnCE::Config_Handlers::DataType const& );

      protected:
      using type_unique_ptr_type = std::unique_ptr< ::DAnCE::Config_Handlers::DataType>;
      type_unique_ptr_type type_;

      public:
      StructMemberType (::XMLSchema::string<char> const& name__,
                        ::DAnCE::Config_Handlers::DataType const& type__);

      explicit StructMemberType (::XSCRT::XML::Element<char> const&);
      StructMemberType (StructMemberType const& s);
      StructMemberType& operator= (StructMemberType const& s);

      StructMemberType (StructMemberType&&) = default;
      StructMemberType& operator= (StructMemberType&&) = default;
    };


    class XSC_XML_Handlers_Export ValueType : public ::XSCRT::Type
    {
      using Base = ::XSCRT::Type;

      // name
      public:
      ::XMLSchema::string<char> const& name () const;
      void name (::XMLSchema::string<char> const& );

      protected:
      using name_unique_ptr_type = std::unique_ptr< ::XMLSchema::string<char>>;
      name_unique_ptr_type name_;

      // typeId
      public:
      ::XMLSchema::string<char> const& typeId () const;
      void typeId (::XMLSchema::string<char> const& );

      protected:
      using typeId_unique_ptr_type = std::unique_ptr< ::XMLSchema::string<char>>;
      typeId_unique_ptr_type typeId_;

      // modifier
      public:
      ::XMLSchema::string<char> const& modifier () const;
      void modifier (::XMLSchema::string<char> const& );

      protected:
      using modifier_unique_ptr_type = std::unique_ptr< ::XMLSchema::string<char>>;
      modifier_unique_ptr_type modifier_;

      // baseType
      public:
      ::DAnCE::Config_Handlers::DataType const& baseType () const;
      void baseType (::DAnCE::Config_Handlers::DataType const& );

      protected:
      using baseType_unique_ptr_type = std::unique_ptr< ::DAnCE::Config_Handlers::DataType>;
      baseType_unique_ptr_type baseType_;

      // member
      public:
      using member_container_type = std::vector< ::DAnCE::Config_Handlers::ValueMemberType>;
      using member_const_iterator = member_container_type::const_iterator;
      member_const_iterator begin_member () const;
      member_const_iterator end_member () const;
      size_t count_member () const;

      protected:
      member_container_type member_;

      public:
      ValueType (::XMLSchema::string<char> const& name__,
                 ::XMLSchema::string<char> const& typeId__,
                 ::XMLSchema::string<char> const& modifier__,
                 ::DAnCE::Config_Handlers::DataType const& baseType__);

      explicit ValueType (::XSCRT::XML::Element<char> const&);
      ValueType (ValueType const& s);
      ValueType& operator= (ValueType const& s);

      ValueType (ValueType&&) = default;
      ValueType& operator= (ValueType&&) = default;
    };


    class XSC_XML_Handlers_Export ValueMemberType : public ::XSCRT::Type
    {
      using Base = ::XSCRT::Type;

      // name
      public:
      ::XMLSchema::string<char> const& name () const;
      void name (::XMLSchema::string<char> const& );

      protected:
      using name_unique_ptr_type = std::unique_ptr< ::XMLSchema::string<char>>;
      name_unique_ptr_type name_;

      // visibility
      public:
      ::XMLSchema::string<char> const& visibility () const;
      void visibility (::XMLSchema::string<char> const& );

      protected:
      using visibility_unique_ptr_type = std::unique_ptr< ::XMLSchema::string<char>>;
      visibility_unique_ptr_type visibility_;

      // type
      public:
      ::DAnCE::Config_Handlers::DataType const& type () const;
      void type (::DAnCE::Config_Handlers::DataType const& );

      protected:
      using type_unique_ptr_type = std::unique_ptr< ::DAnCE::Config_Handlers::DataType>;
      type_unique_ptr_type type_;

      public:
      ValueMemberType (::XMLSchema::string<char> const& name__,
                       ::XMLSchema::string<char> const& visibility__,
                       ::DAnCE::Config_Handlers::DataType const& type__);

      explicit ValueMemberType (::XSCRT::XML::Element<char> const&);
      ValueMemberType (ValueMemberType const& s);
      ValueMemberType& operator= (ValueMemberType const& s);

      ValueMemberType (ValueMemberType&&) = default;
      ValueMemberType& operator= (ValueMemberType&&) = default;
    };


    class XSC_XML_Handlers_Export NamedValue : public ::XSCRT::Type
    {
      using Base = ::XSCRT::Type;

      // name
      public:
      ::XMLSchema::string<char> const& name () const;
      void name (::XMLSchema::string<char> const& );

      protected:
      using name_unique_ptr_type = std::unique_ptr< ::XMLSchema::string<char>>;
      name_unique_ptr_type name_;

      // value
      public:
      ::DAnCE::Config_Handlers::DataValue const& value () const;
      void value (::DAnCE::Config_Handlers::DataValue const& );

      protected:
      using value_unique_ptr_type = std::unique_ptr< ::DAnCE::Config_Handlers::DataValue>;
      value_unique_ptr_type value_;

      public:
      NamedValue (::XMLSchema::string<char> const& name__,
                  ::DAnCE::Config_Handlers::DataValue const& value__);

      explicit NamedValue (::XSCRT::XML::Element<char> const&);
      NamedValue (NamedValue const& s);
      NamedValue& operator= (NamedValue const& s);

      NamedValue (NamedValue&&) = default;
      NamedValue& operator= (NamedValue&&) = default;
    };


    class XSC_XML_Handlers_Export ArrayType : public ::XSCRT::Type
    {
      using Base = ::XSCRT::Type;

      // length
      public:
      ::XMLSchema::unsignedInt const& length () const;
      void length (::XMLSchema::unsignedInt const& );

      protected:
      using length_unique_ptr_type = std::unique_ptr< ::XMLSchema::unsignedInt>;
      length_unique_ptr_type length_;

      // elementType
      public:
      ::DAnCE::Config_Handlers::DataType const& elementType () const;
      void elementType (::DAnCE::Config_Handlers::DataType const& );

      protected:
      using elementType_unique_ptr_type = std::unique_ptr< ::DAnCE::Config_Handlers::DataType>;
      elementType_unique_ptr_type elementType_;

      public:
      ArrayType (::XMLSchema::unsignedInt const& length__,
                 ::DAnCE::Config_Handlers::DataType const& elementType__);

      explicit ArrayType (::XSCRT::XML::Element<char> const&);
      ArrayType (ArrayType const& s);
      ArrayType& operator= (ArrayType const& s);

      ArrayType (ArrayType&&) = default;
      ArrayType& operator= (ArrayType&&) = default;
    };


    class XSC_XML_Handlers_Export SequenceType : public ::XSCRT::Type
    {
      using Base = ::XSCRT::Type;

      // bound
      public:
      bool bound_p () const;
      ::XMLSchema::unsignedInt const& bound () const;
      void bound (::XMLSchema::unsignedInt const& );

      protected:
      using bound_unique_ptr_type = std::unique_ptr< ::XMLSchema::unsignedInt>;
      bound_unique_ptr_type bound_;

      // elementType
      public:
      ::DAnCE::Config_Handlers::DataType const& elementType () const;
      void elementType (::DAnCE::Config_Handlers::DataType const& );

      protected:
      using elementType_unique_ptr_type = std::unique_ptr< ::DAnCE::Config_Handlers::DataType>;
      elementType_unique_ptr_type elementType_;

      public:
      SequenceType (::DAnCE::Config_Handlers::DataType const& elementType__);

      explicit SequenceType (::XSCRT::XML::Element<char> const&);
      SequenceType (SequenceType const& s);
      SequenceType& operator= (SequenceType const& s);

      SequenceType (SequenceType&&) = default;
      SequenceType& operator= (SequenceType&&) = default;
    };


    class XSC_XML_Handlers_Export Any : public ::XSCRT::Type
    {
      using Base = ::XSCRT::Type;

      // type
      public:
      ::DAnCE::Config_Handlers::DataType const& type () const;
      void type (::DAnCE::Config_Handlers::DataType const& );

      protected:
      using type_unique_ptr_type = std::unique_ptr< ::DAnCE::Config_Handlers::DataType>;
      type_unique_ptr_type type_;

      // value
      public:
      ::DAnCE::Config_Handlers::DataValue const& value () const;
      void value (::DAnCE::Config_Handlers::DataValue const& );

      protected:
      using value_unique_ptr_type = std::unique_ptr< ::DAnCE::Config_Handlers::DataValue>;
      value_unique_ptr_type value_;

      public:
      Any (::DAnCE::Config_Handlers::DataType const& type__,
           ::DAnCE::Config_Handlers::DataValue const& value__);

      explicit Any (::XSCRT::XML::Element<char> const&);
      Any (Any const& s);
      Any& operator= (Any const& s);

      Any (Any&&) = default;
      Any& operator= (Any&&) = default;
    };


    class XSC_XML_Handlers_Export Property : public ::XSCRT::Type
    {
      using Base = ::XSCRT::Type;

      // name
      public:
      ::XMLSchema::string<char> const& name () const;
      void name (::XMLSchema::string<char> const& );

      protected:
      using name_unique_ptr_type = std::unique_ptr< ::XMLSchema::string<char>>;
      name_unique_ptr_type name_;

      // value
      public:
      ::DAnCE::Config_Handlers::Any const& value () const;
      void value (::DAnCE::Config_Handlers::Any const& );

      protected:
      using value_unique_ptr_type = std::unique_ptr< ::DAnCE::Config_Handlers::Any>;
      value_unique_ptr_type value_;

      public:
      Property (::XMLSchema::string<char> const& name__,
                ::DAnCE::Config_Handlers::Any const& value__);

      explicit Property (::XSCRT::XML::Element<char> const&);
      Property (Property const& s);
      Property& operator= (Property const& s);

      Property (Property&&) = default;
      Property& operator= (Property&&) = default;
    };


    class XSC_XML_Handlers_Export SatisfierPropertyKind : public ::XSCRT::Type
    {
      public:
      explicit SatisfierPropertyKind (::XSCRT::XML::Element<char> const&);
      explicit SatisfierPropertyKind (::XSCRT::XML::Attribute<char> const&);

      static SatisfierPropertyKind const Quantity;
      static SatisfierPropertyKind const Capacity;
      static SatisfierPropertyKind const Minimum;
      static SatisfierPropertyKind const Maximum;
      static SatisfierPropertyKind const Attribute;
      static SatisfierPropertyKind const Selection;

      enum Value
      {
        Quantity_l, Capacity_l, Minimum_l, Maximum_l, Attribute_l, Selection_l
      };


      Value
      integral () const;

      friend bool XSC_XML_Handlers_Export 
      operator== (SatisfierPropertyKind const& a, SatisfierPropertyKind const& b);

      friend bool XSC_XML_Handlers_Export 
      operator!= (SatisfierPropertyKind const& a, SatisfierPropertyKind const& b);

      private:
      SatisfierPropertyKind (Value v);

      Value v_;
    };

    bool XSC_XML_Handlers_Export operator== (SatisfierPropertyKind const &a, SatisfierPropertyKind const &b);

    bool XSC_XML_Handlers_Export operator!= (SatisfierPropertyKind const &a, SatisfierPropertyKind const &b);


    class XSC_XML_Handlers_Export SatisfierProperty : public ::XSCRT::Type
    {
      using Base = ::XSCRT::Type;

      // name
      public:
      ::XMLSchema::string<char> const& name () const;
      void name (::XMLSchema::string<char> const& );

      protected:
      using name_unique_ptr_type = std::unique_ptr< ::XMLSchema::string<char>>;
      name_unique_ptr_type name_;

      // kind
      public:
      ::DAnCE::Config_Handlers::SatisfierPropertyKind const& kind () const;
      void kind (::DAnCE::Config_Handlers::SatisfierPropertyKind const& );

      protected:
      using kind_unique_ptr_type = std::unique_ptr< ::DAnCE::Config_Handlers::SatisfierPropertyKind>;
      kind_unique_ptr_type kind_;

      // dynamic
      public:
      ::XMLSchema::boolean const& dynamic () const;
      void dynamic (::XMLSchema::boolean const& );

      protected:
      using dynamic_unique_ptr_type = std::unique_ptr< ::XMLSchema::boolean>;
      dynamic_unique_ptr_type dynamic_;

      // value
      public:
      ::DAnCE::Config_Handlers::Any const& value () const;
      void value (::DAnCE::Config_Handlers::Any const& );

      protected:
      using value_unique_ptr_type = std::unique_ptr< ::DAnCE::Config_Handlers::Any>;
      value_unique_ptr_type value_;

      public:
      SatisfierProperty (::XMLSchema::string<char> const& name__,
                         ::DAnCE::Config_Handlers::SatisfierPropertyKind const& kind__,
                         ::XMLSchema::boolean const& dynamic__,
                         ::DAnCE::Config_Handlers::Any const& value__);

      explicit SatisfierProperty (::XSCRT::XML::Element<char> const&);
      SatisfierProperty (SatisfierProperty const& s);
      SatisfierProperty& operator= (SatisfierProperty const& s);

      SatisfierProperty (SatisfierProperty&&) = default;
      SatisfierProperty& operator= (SatisfierProperty&&) = default;
    };


    class XSC_XML_Handlers_Export Resource : public ::XSCRT::Type
    {
      using Base = ::XSCRT::Type;

      // name
      public:
      ::XMLSchema::string<char> const& name () const;
      void name (::XMLSchema::string<char> const& );

      protected:
      using name_unique_ptr_type = std::unique_ptr< ::XMLSchema::string<char>>;
      name_unique_ptr_type name_;

      // resourceType
      public:
      using resourceType_container_type = std::vector< ::XMLSchema::string<char>>;
      using resourceType_const_iterator = resourceType_container_type::const_iterator;
      resourceType_const_iterator begin_resourceType () const;
      resourceType_const_iterator end_resourceType () const;
      size_t count_resourceType () const;

      protected:
      resourceType_container_type resourceType_;

      // property
      public:
      using property_container_type = std::vector< ::DAnCE::Config_Handlers::SatisfierProperty>;
      using property_const_iterator = property_container_type::const_iterator;
      property_const_iterator begin_property () const;
      property_const_iterator end_property () const;
      size_t count_property () const;

      protected:
      property_container_type property_;

      public:
      Resource (::XMLSchema::string<char> const& name__,
                resourceType_container_type const& resourceType__);

      explicit Resource (::XSCRT::XML::Element<char> const&);
      Resource (Resource const& s);
      Resource& operator= (Resource const& s);

      Resource (Resource&&) = default;
      Resource& operator= (Resource&&) = default;
    };


    class XSC_XML_Handlers_Export Requirement : public ::XSCRT::Type
    {
      using Base = ::XSCRT::Type;

      // name
      public:
      ::XMLSchema::string<char> const& name () const;
      void name (::XMLSchema::string<char> const& );

      protected:
      using name_unique_ptr_type = std::unique_ptr< ::XMLSchema::string<char>>;
      name_unique_ptr_type name_;

      // resourceType
      public:
      ::XMLSchema::string<char> const& resourceType () const;
      void resourceType (::XMLSchema::string<char> const& );

      protected:
      using resourceType_unique_ptr_type = std::unique_ptr< ::XMLSchema::string<char>>;
      resourceType_unique_ptr_type resourceType_;

      // property
      public:
      using property_container_type = std::vector< ::DAnCE::Config_Handlers::Property>;
      using property_const_iterator = property_container_type::const_iterator;
      property_const_iterator begin_property () const;
      property_const_iterator end_property () const;
      size_t count_property () const;

      protected:
      property_container_type property_;

      public:
      Requirement (::XMLSchema::string<char> const& name__,
                   ::XMLSchema::string<char> const& resourceType__);

      explicit Requirement (::XSCRT::XML::Element<char> const&);
      Requirement (Requirement const& s);
      Requirement& operator= (Requirement const& s);

      Requirement (Requirement&&) = default;
      Requirement& operator= (Requirement&&) = default;
    };


    class XSC_XML_Handlers_Export ResourceDeploymentDescription : public ::XSCRT::Type
    {
      using Base = ::XSCRT::Type;

      // requirementName
      public:
      ::XMLSchema::string<char> const& requirementName () const;
      void requirementName (::XMLSchema::string<char> const& );

      protected:
      using requirementName_unique_ptr_type = std::unique_ptr< ::XMLSchema::string<char>>;
      requirementName_unique_ptr_type requirementName_;

      // resourceName
      public:
      ::XMLSchema::string<char> const& resourceName () const;
      void resourceName (::XMLSchema::string<char> const& );

      protected:
      using resourceName_unique_ptr_type = std::unique_ptr< ::XMLSchema::string<char>>;
      resourceName_unique_ptr_type resourceName_;

      // property
      public:
      using property_container_type = std::vector< ::DAnCE::Config_Handlers::Property>;
      using property_const_iterator = property_container_type::const_iterator;
      property_const_iterator begin_property () const;
      property_const_iterator end_property () const;
      size_t count_property () const;

      protected:
      property_container_type property_;

      public:
      ResourceDeploymentDescription (::XMLSchema::string<char> const& requirementName__,
                                     ::XMLSchema::string<char> const& resourceName__);

      explicit ResourceDeploymentDescription (::XSCRT::XML::Element<char> const&);
      ResourceDeploymentDescription (ResourceDeploymentDescription const& s);
      ResourceDeploymentDescription& operator= (ResourceDeploymentDescription const& s);

      ResourceDeploymentDescription (ResourceDeploymentDescription&&) = default;
      ResourceDeploymentDescription& operator= (ResourceDeploymentDescription&&) = default;
    };


    class XSC_XML_Handlers_Export ArtifactDeploymentDescription : public ::XSCRT::Type
    {
      using Base = ::XSCRT::Type;

      // name
      public:
      ::XMLSchema::string<char> const& name () const;
      void name (::XMLSchema::string<char> const& );

      protected:
      using name_unique_ptr_type = std::unique_ptr< ::XMLSchema::string<char>>;
      name_unique_ptr_type name_;

      // source
      public:
      using source_container_type = std::vector< ::XMLSchema::string<char>>;
      using source_const_iterator = source_container_type::const_iterator;
      source_const_iterator begin_source () const;
      source_const_iterator end_source () const;
      size_t count_source () const;

      protected:
      source_container_type source_;

      // node
      public:
      ::XMLSchema::string<char> const& node () const;
      void node (::XMLSchema::string<char> const& );

      protected:
      using node_unique_ptr_type = std::unique_ptr< ::XMLSchema::string<char>>;
      node_unique_ptr_type node_;

      // location
      public:
      using location_container_type = std::vector< ::XMLSchema::string<char>>;
      using location_const_iterator = location_container_type::const_iterator;
      location_const_iterator begin_location () const;
      location_const_iterator end_location () const;
      size_t count_location () const;

      protected:
      location_container_type location_;

      // execParameter
      public:
      using execParameter_container_type = std::vector< ::DAnCE::Config_Handlers::Property>;
      using execParameter_const_iterator = execParameter_container_type::const_iterator;
      execParameter_const_iterator begin_execParameter () const;
      execParameter_const_iterator end_execParameter () const;
      size_t count_execParameter () const;

      protected:
      execParameter_container_type execParameter_;

      // deployRequirement
      public:
      using deployRequirement_container_type = std::vector< ::DAnCE::Config_Handlers::Requirement>;
      using deployRequirement_const_iterator = deployRequirement_container_type::const_iterator;
      deployRequirement_const_iterator begin_deployRequirement () const;
      deployRequirement_const_iterator end_deployRequirement () const;
      size_t count_deployRequirement () const;

      protected:
      deployRequirement_container_type deployRequirement_;

      // deployedResource
      public:
      using deployedResource_container_type = std::vector< ::DAnCE::Config_Handlers::ResourceDeploymentDescription>;
      using deployedResource_const_iterator = deployedResource_container_type::const_iterator;
      deployedResource_const_iterator begin_deployedResource () const;
      deployedResource_const_iterator end_deployedResource () const;
      size_t count_deployedResource () const;

      protected:
      deployedResource_container_type deployedResource_;

      // id
      public:
      bool id_p () const;
      ::XMLSchema::ID<char> const& id () const;
      ::XMLSchema::ID<char>& id ();
      void id (::XMLSchema::ID<char> const& );

      protected:
      using id_unique_ptr_type = std::unique_ptr< ::XMLSchema::ID<char>>;
      id_unique_ptr_type id_;

      public:
      ArtifactDeploymentDescription (::XMLSchema::string<char> const& name__,
                                     ::XMLSchema::string<char> const& node__);

      explicit ArtifactDeploymentDescription (::XSCRT::XML::Element<char> const&);
      ArtifactDeploymentDescription (ArtifactDeploymentDescription const& s);
      ArtifactDeploymentDescription& operator= (ArtifactDeploymentDescription const& s);

      ArtifactDeploymentDescription (ArtifactDeploymentDescription&&) = default;
      ArtifactDeploymentDescription& operator= (ArtifactDeploymentDescription&&) = default;
    };


    class XSC_XML_Handlers_Export MonolithicDeploymentDescription : public ::XSCRT::Type
    {
      using Base = ::XSCRT::Type;

      // name
      public:
      ::XMLSchema::string<char> const& name () const;
      void name (::XMLSchema::string<char> const& );

      protected:
      using name_unique_ptr_type = std::unique_ptr< ::XMLSchema::string<char>>;
      name_unique_ptr_type name_;

      // source
      public:
      using source_container_type = std::vector< ::XMLSchema::string<char>>;
      using source_const_iterator = source_container_type::const_iterator;
      source_const_iterator begin_source () const;
      source_const_iterator end_source () const;
      size_t count_source () const;

      protected:
      source_container_type source_;

      // artifact
      public:
      using artifact_container_type = std::vector< ::DAnCE::Config_Handlers::IdRef>;
      using artifact_const_iterator = artifact_container_type::const_iterator;
      artifact_const_iterator begin_artifact () const;
      artifact_const_iterator end_artifact () const;
      size_t count_artifact () const;

      protected:
      artifact_container_type artifact_;

      // execParameter
      public:
      using execParameter_container_type = std::vector< ::DAnCE::Config_Handlers::Property>;
      using execParameter_const_iterator = execParameter_container_type::const_iterator;
      execParameter_const_iterator begin_execParameter () const;
      execParameter_const_iterator end_execParameter () const;
      size_t count_execParameter () const;

      protected:
      execParameter_container_type execParameter_;

      // deployRequirement
      public:
      using deployRequirement_container_type = std::vector< ::DAnCE::Config_Handlers::Requirement>;
      using deployRequirement_const_iterator = deployRequirement_container_type::const_iterator;
      deployRequirement_const_iterator begin_deployRequirement () const;
      deployRequirement_const_iterator end_deployRequirement () const;
      size_t count_deployRequirement () const;

      protected:
      deployRequirement_container_type deployRequirement_;

      // id
      public:
      bool id_p () const;
      ::XMLSchema::ID<char> const& id () const;
      ::XMLSchema::ID<char>& id ();
      void id (::XMLSchema::ID<char> const& );

      protected:
      using id_unique_ptr_type = std::unique_ptr< ::XMLSchema::ID<char>>;
      id_unique_ptr_type id_;

      public:
      MonolithicDeploymentDescription (::XMLSchema::string<char> const& name__);

      explicit MonolithicDeploymentDescription (::XSCRT::XML::Element<char> const&);
      MonolithicDeploymentDescription (MonolithicDeploymentDescription const& s);
      MonolithicDeploymentDescription& operator= (MonolithicDeploymentDescription const& s);

      MonolithicDeploymentDescription (MonolithicDeploymentDescription&&) = default;
      MonolithicDeploymentDescription& operator= (MonolithicDeploymentDescription&&) = default;
    };


    class XSC_XML_Handlers_Export ResourceUsageKind : public ::XSCRT::Type
    {
      public:
      explicit ResourceUsageKind (::XSCRT::XML::Element<char> const&);
      explicit ResourceUsageKind (::XSCRT::XML::Attribute<char> const&);

      static ResourceUsageKind const None;
      static ResourceUsageKind const InstanceUsesResource;
      static ResourceUsageKind const ResourceUsesInstance;
      static ResourceUsageKind const PortUsesResource;
      static ResourceUsageKind const ResourceUsesPort;

      enum Value
      {
        None_l, InstanceUsesResource_l, ResourceUsesInstance_l, PortUsesResource_l, ResourceUsesPort_l
      };


      Value
      integral () const;

      friend bool XSC_XML_Handlers_Export 
      operator== (ResourceUsageKind const& a, ResourceUsageKind const& b);

      friend bool XSC_XML_Handlers_Export 
      operator!= (ResourceUsageKind const& a, ResourceUsageKind const& b);

      private:
      ResourceUsageKind (Value v);

      Value v_;
    };

    bool XSC_XML_Handlers_Export operator== (ResourceUsageKind const &a, ResourceUsageKind const &b);

    bool XSC_XML_Handlers_Export operator!= (ResourceUsageKind const &a, ResourceUsageKind const &b);


    class XSC_XML_Handlers_Export InstanceResourceDeploymentDescription : public ::XSCRT::Type
    {
      using Base = ::XSCRT::Type;

      // resourceUsage
      public:
      ::DAnCE::Config_Handlers::ResourceUsageKind const& resourceUsage () const;
      void resourceUsage (::DAnCE::Config_Handlers::ResourceUsageKind const& );

      protected:
      using resourceUsage_unique_ptr_type = std::unique_ptr< ::DAnCE::Config_Handlers::ResourceUsageKind>;
      resourceUsage_unique_ptr_type resourceUsage_;

      // requirementName
      public:
      ::XMLSchema::string<char> const& requirementName () const;
      void requirementName (::XMLSchema::string<char> const& );

      protected:
      using requirementName_unique_ptr_type = std::unique_ptr< ::XMLSchema::string<char>>;
      requirementName_unique_ptr_type requirementName_;

      // resourceName
      public:
      ::XMLSchema::string<char> const& resourceName () const;
      void resourceName (::XMLSchema::string<char> const& );

      protected:
      using resourceName_unique_ptr_type = std::unique_ptr< ::XMLSchema::string<char>>;
      resourceName_unique_ptr_type resourceName_;

      // property
      public:
      using property_container_type = std::vector< ::DAnCE::Config_Handlers::Property>;
      using property_const_iterator = property_container_type::const_iterator;
      property_const_iterator begin_property () const;
      property_const_iterator end_property () const;
      size_t count_property () const;

      protected:
      property_container_type property_;

      public:
      InstanceResourceDeploymentDescription (::DAnCE::Config_Handlers::ResourceUsageKind const& resourceUsage__,
                                             ::XMLSchema::string<char> const& requirementName__,
                                             ::XMLSchema::string<char> const& resourceName__);

      explicit InstanceResourceDeploymentDescription (::XSCRT::XML::Element<char> const&);
      InstanceResourceDeploymentDescription (InstanceResourceDeploymentDescription const& s);
      InstanceResourceDeploymentDescription& operator= (InstanceResourceDeploymentDescription const& s);

      InstanceResourceDeploymentDescription (InstanceResourceDeploymentDescription&&) = default;
      InstanceResourceDeploymentDescription& operator= (InstanceResourceDeploymentDescription&&) = default;
    };


    class XSC_XML_Handlers_Export InstanceDeploymentDescription : public ::XSCRT::Type
    {
      using Base = ::XSCRT::Type;

      // name
      public:
      ::XMLSchema::string<char> const& name () const;
      void name (::XMLSchema::string<char> const& );

      protected:
      using name_unique_ptr_type = std::unique_ptr< ::XMLSchema::string<char>>;
      name_unique_ptr_type name_;

      // node
      public:
      ::XMLSchema::string<char> const& node () const;
      void node (::XMLSchema::string<char> const& );

      protected:
      using node_unique_ptr_type = std::unique_ptr< ::XMLSchema::string<char>>;
      node_unique_ptr_type node_;

      // source
      public:
      ::XMLSchema::string<char> const& source () const;
      void source (::XMLSchema::string<char> const& );

      protected:
      using source_unique_ptr_type = std::unique_ptr< ::XMLSchema::string<char>>;
      source_unique_ptr_type source_;

      // implementation
      public:
      ::DAnCE::Config_Handlers::IdRef const& implementation () const;
      void implementation (::DAnCE::Config_Handlers::IdRef const& );

      protected:
      using implementation_unique_ptr_type = std::unique_ptr< ::DAnCE::Config_Handlers::IdRef>;
      implementation_unique_ptr_type implementation_;

      // configProperty
      public:
      using configProperty_container_type = std::vector< ::DAnCE::Config_Handlers::Property>;
      using configProperty_const_iterator = configProperty_container_type::const_iterator;
      configProperty_const_iterator begin_configProperty () const;
      configProperty_const_iterator end_configProperty () const;
      size_t count_configProperty () const;

      protected:
      configProperty_container_type configProperty_;

      // deployedResource
      public:
      using deployedResource_container_type = std::vector< ::DAnCE::Config_Handlers::InstanceResourceDeploymentDescription>;
      using deployedResource_const_iterator = deployedResource_container_type::const_iterator;
      deployedResource_const_iterator begin_deployedResource () const;
      deployedResource_const_iterator end_deployedResource () const;
      size_t count_deployedResource () const;

      protected:
      deployedResource_container_type deployedResource_;

      // deployedSharedResource
      public:
      using deployedSharedResource_container_type = std::vector< ::DAnCE::Config_Handlers::InstanceResourceDeploymentDescription>;
      using deployedSharedResource_const_iterator = deployedSharedResource_container_type::const_iterator;
      deployedSharedResource_const_iterator begin_deployedSharedResource () const;
      deployedSharedResource_const_iterator end_deployedSharedResource () const;
      size_t count_deployedSharedResource () const;

      protected:
      deployedSharedResource_container_type deployedSharedResource_;

      // id
      public:
      bool id_p () const;
      ::XMLSchema::ID<char> const& id () const;
      ::XMLSchema::ID<char>& id ();
      void id (::XMLSchema::ID<char> const& );

      protected:
      using id_unique_ptr_type = std::unique_ptr< ::XMLSchema::ID<char>>;
      id_unique_ptr_type id_;

      public:
      InstanceDeploymentDescription (::XMLSchema::string<char> const& name__,
                                     ::XMLSchema::string<char> const& node__,
                                     ::XMLSchema::string<char> const& source__,
                                     ::DAnCE::Config_Handlers::IdRef const& implementation__);

      explicit InstanceDeploymentDescription (::XSCRT::XML::Element<char> const&);
      InstanceDeploymentDescription (InstanceDeploymentDescription const& s);
      InstanceDeploymentDescription& operator= (InstanceDeploymentDescription const& s);

      InstanceDeploymentDescription (InstanceDeploymentDescription&&) = default;
      InstanceDeploymentDescription& operator= (InstanceDeploymentDescription&&) = default;
    };


    class XSC_XML_Handlers_Export CCMComponentPortKind : public ::XSCRT::Type
    {
      public:
      explicit CCMComponentPortKind (::XSCRT::XML::Element<char> const&);
      explicit CCMComponentPortKind (::XSCRT::XML::Attribute<char> const&);

      static CCMComponentPortKind const Facet;
      static CCMComponentPortKind const SimplexReceptacle;
      static CCMComponentPortKind const MultiplexReceptacle;
      static CCMComponentPortKind const EventEmitter;
      static CCMComponentPortKind const EventPublisher;
      static CCMComponentPortKind const EventConsumer;
      static CCMComponentPortKind const ExtendedPort;
      static CCMComponentPortKind const MirrorPort;

      enum Value
      {
        Facet_l, SimplexReceptacle_l, MultiplexReceptacle_l, EventEmitter_l, EventPublisher_l, EventConsumer_l, ExtendedPort_l, MirrorPort_l
      };


      Value
      integral () const;

      friend bool XSC_XML_Handlers_Export 
      operator== (CCMComponentPortKind const& a, CCMComponentPortKind const& b);

      friend bool XSC_XML_Handlers_Export 
      operator!= (CCMComponentPortKind const& a, CCMComponentPortKind const& b);

      private:
      CCMComponentPortKind (Value v);

      Value v_;
    };

    bool XSC_XML_Handlers_Export operator== (CCMComponentPortKind const &a, CCMComponentPortKind const &b);

    bool XSC_XML_Handlers_Export operator!= (CCMComponentPortKind const &a, CCMComponentPortKind const &b);


    class XSC_XML_Handlers_Export ComponentPortDescription : public ::XSCRT::Type
    {
      using Base = ::XSCRT::Type;

      // name
      public:
      ::XMLSchema::string<char> const& name () const;
      void name (::XMLSchema::string<char> const& );

      protected:
      using name_unique_ptr_type = std::unique_ptr< ::XMLSchema::string<char>>;
      name_unique_ptr_type name_;

      // specificType
      public:
      bool specificType_p () const;
      ::XMLSchema::string<char> const& specificType () const;
      void specificType (::XMLSchema::string<char> const& );

      protected:
      using specificType_unique_ptr_type = std::unique_ptr< ::XMLSchema::string<char>>;
      specificType_unique_ptr_type specificType_;

      // supportedType
      public:
      using supportedType_container_type = std::vector< ::XMLSchema::string<char>>;
      using supportedType_const_iterator = supportedType_container_type::const_iterator;
      supportedType_const_iterator begin_supportedType () const;
      supportedType_const_iterator end_supportedType () const;
      size_t count_supportedType () const;

      protected:
      supportedType_container_type supportedType_;

      // provider
      public:
      ::XMLSchema::boolean const& provider () const;
      void provider (::XMLSchema::boolean const& );

      protected:
      using provider_unique_ptr_type = std::unique_ptr< ::XMLSchema::boolean>;
      provider_unique_ptr_type provider_;

      // exclusiveProvider
      public:
      ::XMLSchema::boolean const& exclusiveProvider () const;
      void exclusiveProvider (::XMLSchema::boolean const& );

      protected:
      using exclusiveProvider_unique_ptr_type = std::unique_ptr< ::XMLSchema::boolean>;
      exclusiveProvider_unique_ptr_type exclusiveProvider_;

      // exclusiveUser
      public:
      ::XMLSchema::boolean const& exclusiveUser () const;
      void exclusiveUser (::XMLSchema::boolean const& );

      protected:
      using exclusiveUser_unique_ptr_type = std::unique_ptr< ::XMLSchema::boolean>;
      exclusiveUser_unique_ptr_type exclusiveUser_;

      // optional
      public:
      ::XMLSchema::boolean const& optional () const;
      void optional (::XMLSchema::boolean const& );

      protected:
      using optional_unique_ptr_type = std::unique_ptr< ::XMLSchema::boolean>;
      optional_unique_ptr_type optional_;

      // kind
      public:
      ::DAnCE::Config_Handlers::CCMComponentPortKind const& kind () const;
      void kind (::DAnCE::Config_Handlers::CCMComponentPortKind const& );

      protected:
      using kind_unique_ptr_type = std::unique_ptr< ::DAnCE::Config_Handlers::CCMComponentPortKind>;
      kind_unique_ptr_type kind_;

      // templateParam
      public:
      using templateParam_container_type = std::vector< ::XMLSchema::string<char>>;
      using templateParam_const_iterator = templateParam_container_type::const_iterator;
      templateParam_const_iterator begin_templateParam () const;
      templateParam_const_iterator end_templateParam () const;
      size_t count_templateParam () const;

      protected:
      templateParam_container_type templateParam_;

      public:
      ComponentPortDescription (::XMLSchema::string<char> const& name__,
                                ::XMLSchema::boolean const& provider__,
                                ::XMLSchema::boolean const& exclusiveProvider__,
                                ::XMLSchema::boolean const& exclusiveUser__,
                                ::XMLSchema::boolean const& optional__,
                                ::DAnCE::Config_Handlers::CCMComponentPortKind const& kind__);

      explicit ComponentPortDescription (::XSCRT::XML::Element<char> const&);
      ComponentPortDescription (ComponentPortDescription const& s);
      ComponentPortDescription& operator= (ComponentPortDescription const& s);

      ComponentPortDescription (ComponentPortDescription&&) = default;
      ComponentPortDescription& operator= (ComponentPortDescription&&) = default;
    };


    class XSC_XML_Handlers_Export ComponentPropertyDescription : public ::XSCRT::Type
    {
      using Base = ::XSCRT::Type;

      // name
      public:
      ::XMLSchema::string<char> const& name () const;
      void name (::XMLSchema::string<char> const& );

      protected:
      using name_unique_ptr_type = std::unique_ptr< ::XMLSchema::string<char>>;
      name_unique_ptr_type name_;

      // type
      public:
      ::DAnCE::Config_Handlers::DataType const& type () const;
      void type (::DAnCE::Config_Handlers::DataType const& );

      protected:
      using type_unique_ptr_type = std::unique_ptr< ::DAnCE::Config_Handlers::DataType>;
      type_unique_ptr_type type_;

      public:
      ComponentPropertyDescription (::XMLSchema::string<char> const& name__,
                                    ::DAnCE::Config_Handlers::DataType const& type__);

      explicit ComponentPropertyDescription (::XSCRT::XML::Element<char> const&);
      ComponentPropertyDescription (ComponentPropertyDescription const& s);
      ComponentPropertyDescription& operator= (ComponentPropertyDescription const& s);

      ComponentPropertyDescription (ComponentPropertyDescription&&) = default;
      ComponentPropertyDescription& operator= (ComponentPropertyDescription&&) = default;
    };


    class XSC_XML_Handlers_Export ComponentExternalPortEndpoint : public ::XSCRT::Type
    {
      using Base = ::XSCRT::Type;

      // portName
      public:
      ::XMLSchema::string<char> const& portName () const;
      void portName (::XMLSchema::string<char> const& );

      protected:
      using portName_unique_ptr_type = std::unique_ptr< ::XMLSchema::string<char>>;
      portName_unique_ptr_type portName_;

      public:
      ComponentExternalPortEndpoint (::XMLSchema::string<char> const& portName__);

      explicit ComponentExternalPortEndpoint (::XSCRT::XML::Element<char> const&);
      ComponentExternalPortEndpoint (ComponentExternalPortEndpoint const& s);
      ComponentExternalPortEndpoint& operator= (ComponentExternalPortEndpoint const& s);

      ComponentExternalPortEndpoint (ComponentExternalPortEndpoint&&) = default;
      ComponentExternalPortEndpoint& operator= (ComponentExternalPortEndpoint&&) = default;
    };


    class XSC_XML_Handlers_Export PlanSubcomponentPortEndpoint : public ::XSCRT::Type
    {
      using Base = ::XSCRT::Type;

      // portName
      public:
      ::XMLSchema::string<char> const& portName () const;
      void portName (::XMLSchema::string<char> const& );

      protected:
      using portName_unique_ptr_type = std::unique_ptr< ::XMLSchema::string<char>>;
      portName_unique_ptr_type portName_;

      // provider
      public:
      bool provider_p () const;
      ::XMLSchema::string<char> const& provider () const;
      void provider (::XMLSchema::string<char> const& );

      protected:
      using provider_unique_ptr_type = std::unique_ptr< ::XMLSchema::string<char>>;
      provider_unique_ptr_type provider_;

      // kind
      public:
      ::DAnCE::Config_Handlers::CCMComponentPortKind const& kind () const;
      void kind (::DAnCE::Config_Handlers::CCMComponentPortKind const& );

      protected:
      using kind_unique_ptr_type = std::unique_ptr< ::DAnCE::Config_Handlers::CCMComponentPortKind>;
      kind_unique_ptr_type kind_;

      // instance
      public:
      ::DAnCE::Config_Handlers::IdRef const& instance () const;
      void instance (::DAnCE::Config_Handlers::IdRef const& );

      protected:
      using instance_unique_ptr_type = std::unique_ptr< ::DAnCE::Config_Handlers::IdRef>;
      instance_unique_ptr_type instance_;

      public:
      PlanSubcomponentPortEndpoint (::XMLSchema::string<char> const& portName__,
                                    ::DAnCE::Config_Handlers::CCMComponentPortKind const& kind__,
                                    ::DAnCE::Config_Handlers::IdRef const& instance__);

      explicit PlanSubcomponentPortEndpoint (::XSCRT::XML::Element<char> const&);
      PlanSubcomponentPortEndpoint (PlanSubcomponentPortEndpoint const& s);
      PlanSubcomponentPortEndpoint& operator= (PlanSubcomponentPortEndpoint const& s);

      PlanSubcomponentPortEndpoint (PlanSubcomponentPortEndpoint&&) = default;
      PlanSubcomponentPortEndpoint& operator= (PlanSubcomponentPortEndpoint&&) = default;
    };


    class XSC_XML_Handlers_Export ExternalReferenceEndpoint : public ::XSCRT::Type
    {
      using Base = ::XSCRT::Type;

      // location
      public:
      ::XMLSchema::string<char> const& location () const;
      void location (::XMLSchema::string<char> const& );

      protected:
      using location_unique_ptr_type = std::unique_ptr< ::XMLSchema::string<char>>;
      location_unique_ptr_type location_;

      // provider
      public:
      ::XMLSchema::boolean const& provider () const;
      void provider (::XMLSchema::boolean const& );

      protected:
      using provider_unique_ptr_type = std::unique_ptr< ::XMLSchema::boolean>;
      provider_unique_ptr_type provider_;

      // portName
      public:
      bool portName_p () const;
      ::XMLSchema::string<char> const& portName () const;
      void portName (::XMLSchema::string<char> const& );

      protected:
      using portName_unique_ptr_type = std::unique_ptr< ::XMLSchema::string<char>>;
      portName_unique_ptr_type portName_;

      // supportedType
      public:
      using supportedType_container_type = std::vector< ::XMLSchema::string<char>>;
      using supportedType_const_iterator = supportedType_container_type::const_iterator;
      supportedType_const_iterator begin_supportedType () const;
      supportedType_const_iterator end_supportedType () const;
      size_t count_supportedType () const;

      protected:
      supportedType_container_type supportedType_;

      public:
      ExternalReferenceEndpoint (::XMLSchema::string<char> const& location__,
                                 ::XMLSchema::boolean const& provider__);

      explicit ExternalReferenceEndpoint (::XSCRT::XML::Element<char> const&);
      ExternalReferenceEndpoint (ExternalReferenceEndpoint const& s);
      ExternalReferenceEndpoint& operator= (ExternalReferenceEndpoint const& s);

      ExternalReferenceEndpoint (ExternalReferenceEndpoint&&) = default;
      ExternalReferenceEndpoint& operator= (ExternalReferenceEndpoint&&) = default;
    };


    class XSC_XML_Handlers_Export ConnectionResourceDeploymentDescription : public ::XSCRT::Type
    {
      using Base = ::XSCRT::Type;

      // targetName
      public:
      ::XMLSchema::string<char> const& targetName () const;
      void targetName (::XMLSchema::string<char> const& );

      protected:
      using targetName_unique_ptr_type = std::unique_ptr< ::XMLSchema::string<char>>;
      targetName_unique_ptr_type targetName_;

      // requirementName
      public:
      ::XMLSchema::string<char> const& requirementName () const;
      void requirementName (::XMLSchema::string<char> const& );

      protected:
      using requirementName_unique_ptr_type = std::unique_ptr< ::XMLSchema::string<char>>;
      requirementName_unique_ptr_type requirementName_;

      // resourceName
      public:
      ::XMLSchema::string<char> const& resourceName () const;
      void resourceName (::XMLSchema::string<char> const& );

      protected:
      using resourceName_unique_ptr_type = std::unique_ptr< ::XMLSchema::string<char>>;
      resourceName_unique_ptr_type resourceName_;

      // property
      public:
      using property_container_type = std::vector< ::DAnCE::Config_Handlers::Property>;
      using property_const_iterator = property_container_type::const_iterator;
      property_const_iterator begin_property () const;
      property_const_iterator end_property () const;
      size_t count_property () const;

      protected:
      property_container_type property_;

      public:
      ConnectionResourceDeploymentDescription (::XMLSchema::string<char> const& targetName__,
                                               ::XMLSchema::string<char> const& requirementName__,
                                               ::XMLSchema::string<char> const& resourceName__);

      explicit ConnectionResourceDeploymentDescription (::XSCRT::XML::Element<char> const&);
      ConnectionResourceDeploymentDescription (ConnectionResourceDeploymentDescription const& s);
      ConnectionResourceDeploymentDescription& operator= (ConnectionResourceDeploymentDescription const& s);

      ConnectionResourceDeploymentDescription (ConnectionResourceDeploymentDescription&&) = default;
      ConnectionResourceDeploymentDescription& operator= (ConnectionResourceDeploymentDescription&&) = default;
    };


    class XSC_XML_Handlers_Export PlanConnectionDescription : public ::XSCRT::Type
    {
      using Base = ::XSCRT::Type;

      // name
      public:
      ::XMLSchema::string<char> const& name () const;
      void name (::XMLSchema::string<char> const& );

      protected:
      using name_unique_ptr_type = std::unique_ptr< ::XMLSchema::string<char>>;
      name_unique_ptr_type name_;

      // source
      public:
      bool source_p () const;
      ::XMLSchema::string<char> const& source () const;
      void source (::XMLSchema::string<char> const& );

      protected:
      using source_unique_ptr_type = std::unique_ptr< ::XMLSchema::string<char>>;
      source_unique_ptr_type source_;

      // deployRequirement
      public:
      using deployRequirement_container_type = std::vector< ::DAnCE::Config_Handlers::Requirement>;
      using deployRequirement_const_iterator = deployRequirement_container_type::const_iterator;
      deployRequirement_const_iterator begin_deployRequirement () const;
      deployRequirement_const_iterator end_deployRequirement () const;
      size_t count_deployRequirement () const;

      protected:
      deployRequirement_container_type deployRequirement_;

      // externalEndpoint
      public:
      using externalEndpoint_container_type = std::vector< ::DAnCE::Config_Handlers::ComponentExternalPortEndpoint>;
      using externalEndpoint_const_iterator = externalEndpoint_container_type::const_iterator;
      externalEndpoint_const_iterator begin_externalEndpoint () const;
      externalEndpoint_const_iterator end_externalEndpoint () const;
      size_t count_externalEndpoint () const;

      protected:
      externalEndpoint_container_type externalEndpoint_;

      // internalEndpoint
      public:
      using internalEndpoint_container_type = std::vector< ::DAnCE::Config_Handlers::PlanSubcomponentPortEndpoint>;
      using internalEndpoint_const_iterator = internalEndpoint_container_type::const_iterator;
      internalEndpoint_const_iterator begin_internalEndpoint () const;
      internalEndpoint_const_iterator end_internalEndpoint () const;
      size_t count_internalEndpoint () const;

      protected:
      internalEndpoint_container_type internalEndpoint_;

      // externalReference
      public:
      using externalReference_container_type = std::vector< ::DAnCE::Config_Handlers::ExternalReferenceEndpoint>;
      using externalReference_const_iterator = externalReference_container_type::const_iterator;
      externalReference_const_iterator begin_externalReference () const;
      externalReference_const_iterator end_externalReference () const;
      size_t count_externalReference () const;

      protected:
      externalReference_container_type externalReference_;

      // deployedResource
      public:
      using deployedResource_container_type = std::vector< ::DAnCE::Config_Handlers::ConnectionResourceDeploymentDescription>;
      using deployedResource_const_iterator = deployedResource_container_type::const_iterator;
      deployedResource_const_iterator begin_deployedResource () const;
      deployedResource_const_iterator end_deployedResource () const;
      size_t count_deployedResource () const;

      protected:
      deployedResource_container_type deployedResource_;

      public:
      PlanConnectionDescription (::XMLSchema::string<char> const& name__);

      explicit PlanConnectionDescription (::XSCRT::XML::Element<char> const&);
      PlanConnectionDescription (PlanConnectionDescription const& s);
      PlanConnectionDescription& operator= (PlanConnectionDescription const& s);

      PlanConnectionDescription (PlanConnectionDescription&&) = default;
      PlanConnectionDescription& operator= (PlanConnectionDescription&&) = default;
    };


    class XSC_XML_Handlers_Export ImplementationDependency : public ::XSCRT::Type
    {
      using Base = ::XSCRT::Type;

      // requiredType
      public:
      ::XMLSchema::string<char> const& requiredType () const;
      void requiredType (::XMLSchema::string<char> const& );

      protected:
      using requiredType_unique_ptr_type = std::unique_ptr< ::XMLSchema::string<char>>;
      requiredType_unique_ptr_type requiredType_;

      public:
      ImplementationDependency (::XMLSchema::string<char> const& requiredType__);

      explicit ImplementationDependency (::XSCRT::XML::Element<char> const&);
      ImplementationDependency (ImplementationDependency const& s);
      ImplementationDependency& operator= (ImplementationDependency const& s);

      ImplementationDependency (ImplementationDependency&&) = default;
      ImplementationDependency& operator= (ImplementationDependency&&) = default;
    };


    class XSC_XML_Handlers_Export Capability : public ::XSCRT::Type
    {
      using Base = ::XSCRT::Type;

      // name
      public:
      ::XMLSchema::string<char> const& name () const;
      void name (::XMLSchema::string<char> const& );

      protected:
      using name_unique_ptr_type = std::unique_ptr< ::XMLSchema::string<char>>;
      name_unique_ptr_type name_;

      // resourceType
      public:
      using resourceType_container_type = std::vector< ::XMLSchema::string<char>>;
      using resourceType_const_iterator = resourceType_container_type::const_iterator;
      resourceType_const_iterator begin_resourceType () const;
      resourceType_const_iterator end_resourceType () const;
      size_t count_resourceType () const;

      protected:
      resourceType_container_type resourceType_;

      // property
      public:
      using property_container_type = std::vector< ::DAnCE::Config_Handlers::SatisfierProperty>;
      using property_const_iterator = property_container_type::const_iterator;
      property_const_iterator begin_property () const;
      property_const_iterator end_property () const;
      size_t count_property () const;

      protected:
      property_container_type property_;

      public:
      Capability (::XMLSchema::string<char> const& name__);

      explicit Capability (::XSCRT::XML::Element<char> const&);
      Capability (Capability const& s);
      Capability& operator= (Capability const& s);

      Capability (Capability&&) = default;
      Capability& operator= (Capability&&) = default;
    };


    class XSC_XML_Handlers_Export ImplementationRequirement : public ::XSCRT::Type
    {
      using Base = ::XSCRT::Type;

      // resourceUsage
      public:
      bool resourceUsage_p () const;
      ::DAnCE::Config_Handlers::ResourceUsageKind const& resourceUsage () const;
      void resourceUsage (::DAnCE::Config_Handlers::ResourceUsageKind const& );

      protected:
      using resourceUsage_unique_ptr_type = std::unique_ptr< ::DAnCE::Config_Handlers::ResourceUsageKind>;
      resourceUsage_unique_ptr_type resourceUsage_;

      // resourcePort
      public:
      bool resourcePort_p () const;
      ::XMLSchema::string<char> const& resourcePort () const;
      void resourcePort (::XMLSchema::string<char> const& );

      protected:
      using resourcePort_unique_ptr_type = std::unique_ptr< ::XMLSchema::string<char>>;
      resourcePort_unique_ptr_type resourcePort_;

      // componentPort
      public:
      bool componentPort_p () const;
      ::XMLSchema::string<char> const& componentPort () const;
      void componentPort (::XMLSchema::string<char> const& );

      protected:
      using componentPort_unique_ptr_type = std::unique_ptr< ::XMLSchema::string<char>>;
      componentPort_unique_ptr_type componentPort_;

      // resourceType
      public:
      ::XMLSchema::string<char> const& resourceType () const;
      void resourceType (::XMLSchema::string<char> const& );

      protected:
      using resourceType_unique_ptr_type = std::unique_ptr< ::XMLSchema::string<char>>;
      resourceType_unique_ptr_type resourceType_;

      // name
      public:
      ::XMLSchema::string<char> const& name () const;
      void name (::XMLSchema::string<char> const& );

      protected:
      using name_unique_ptr_type = std::unique_ptr< ::XMLSchema::string<char>>;
      name_unique_ptr_type name_;

      // property
      public:
      using property_container_type = std::vector< ::DAnCE::Config_Handlers::Property>;
      using property_const_iterator = property_container_type::const_iterator;
      property_const_iterator begin_property () const;
      property_const_iterator end_property () const;
      size_t count_property () const;

      protected:
      property_container_type property_;

      public:
      ImplementationRequirement (::XMLSchema::string<char> const& resourceType__,
                                 ::XMLSchema::string<char> const& name__);

      explicit ImplementationRequirement (::XSCRT::XML::Element<char> const&);
      ImplementationRequirement (ImplementationRequirement const& s);
      ImplementationRequirement& operator= (ImplementationRequirement const& s);

      ImplementationRequirement (ImplementationRequirement&&) = default;
      ImplementationRequirement& operator= (ImplementationRequirement&&) = default;
    };


    class XSC_XML_Handlers_Export SubcomponentPortEndpoint : public ::XSCRT::Type
    {
      using Base = ::XSCRT::Type;

      // portName
      public:
      ::XMLSchema::string<char> const& portName () const;
      void portName (::XMLSchema::string<char> const& );

      protected:
      using portName_unique_ptr_type = std::unique_ptr< ::XMLSchema::string<char>>;
      portName_unique_ptr_type portName_;

      // instance
      public:
      ::DAnCE::Config_Handlers::IdRef const& instance () const;
      void instance (::DAnCE::Config_Handlers::IdRef const& );

      protected:
      using instance_unique_ptr_type = std::unique_ptr< ::DAnCE::Config_Handlers::IdRef>;
      instance_unique_ptr_type instance_;

      public:
      SubcomponentPortEndpoint (::XMLSchema::string<char> const& portName__,
                                ::DAnCE::Config_Handlers::IdRef const& instance__);

      explicit SubcomponentPortEndpoint (::XSCRT::XML::Element<char> const&);
      SubcomponentPortEndpoint (SubcomponentPortEndpoint const& s);
      SubcomponentPortEndpoint& operator= (SubcomponentPortEndpoint const& s);

      SubcomponentPortEndpoint (SubcomponentPortEndpoint&&) = default;
      SubcomponentPortEndpoint& operator= (SubcomponentPortEndpoint&&) = default;
    };


    class XSC_XML_Handlers_Export AssemblyConnectionDescription : public ::XSCRT::Type
    {
      using Base = ::XSCRT::Type;

      // name
      public:
      ::XMLSchema::string<char> const& name () const;
      void name (::XMLSchema::string<char> const& );

      protected:
      using name_unique_ptr_type = std::unique_ptr< ::XMLSchema::string<char>>;
      name_unique_ptr_type name_;

      // deployRequirement
      public:
      using deployRequirement_container_type = std::vector< ::DAnCE::Config_Handlers::Requirement>;
      using deployRequirement_const_iterator = deployRequirement_container_type::const_iterator;
      deployRequirement_const_iterator begin_deployRequirement () const;
      deployRequirement_const_iterator end_deployRequirement () const;
      size_t count_deployRequirement () const;

      protected:
      deployRequirement_container_type deployRequirement_;

      // internalEndpoint
      public:
      using internalEndpoint_container_type = std::vector< ::DAnCE::Config_Handlers::SubcomponentPortEndpoint>;
      using internalEndpoint_const_iterator = internalEndpoint_container_type::const_iterator;
      internalEndpoint_const_iterator begin_internalEndpoint () const;
      internalEndpoint_const_iterator end_internalEndpoint () const;
      size_t count_internalEndpoint () const;

      protected:
      internalEndpoint_container_type internalEndpoint_;

      // externalEndpoint
      public:
      using externalEndpoint_container_type = std::vector< ::DAnCE::Config_Handlers::ComponentExternalPortEndpoint>;
      using externalEndpoint_const_iterator = externalEndpoint_container_type::const_iterator;
      externalEndpoint_const_iterator begin_externalEndpoint () const;
      externalEndpoint_const_iterator end_externalEndpoint () const;
      size_t count_externalEndpoint () const;

      protected:
      externalEndpoint_container_type externalEndpoint_;

      // externalReference
      public:
      using externalReference_container_type = std::vector< ::DAnCE::Config_Handlers::ExternalReferenceEndpoint>;
      using externalReference_const_iterator = externalReference_container_type::const_iterator;
      externalReference_const_iterator begin_externalReference () const;
      externalReference_const_iterator end_externalReference () const;
      size_t count_externalReference () const;

      protected:
      externalReference_container_type externalReference_;

      public:
      AssemblyConnectionDescription (::XMLSchema::string<char> const& name__);

      explicit AssemblyConnectionDescription (::XSCRT::XML::Element<char> const&);
      AssemblyConnectionDescription (AssemblyConnectionDescription const& s);
      AssemblyConnectionDescription& operator= (AssemblyConnectionDescription const& s);

      AssemblyConnectionDescription (AssemblyConnectionDescription&&) = default;
      AssemblyConnectionDescription& operator= (AssemblyConnectionDescription&&) = default;
    };


    class XSC_XML_Handlers_Export PlanLocalityKind : public ::XSCRT::Type
    {
      public:
      explicit PlanLocalityKind (::XSCRT::XML::Element<char> const&);
      explicit PlanLocalityKind (::XSCRT::XML::Attribute<char> const&);

      static PlanLocalityKind const SameProcess;
      static PlanLocalityKind const DifferentProcess;
      static PlanLocalityKind const NoConstraint;

      enum Value
      {
        SameProcess_l, DifferentProcess_l, NoConstraint_l
      };


      Value
      integral () const;

      friend bool XSC_XML_Handlers_Export 
      operator== (PlanLocalityKind const& a, PlanLocalityKind const& b);

      friend bool XSC_XML_Handlers_Export 
      operator!= (PlanLocalityKind const& a, PlanLocalityKind const& b);

      private:
      PlanLocalityKind (Value v);

      Value v_;
    };

    bool XSC_XML_Handlers_Export operator== (PlanLocalityKind const &a, PlanLocalityKind const &b);

    bool XSC_XML_Handlers_Export operator!= (PlanLocalityKind const &a, PlanLocalityKind const &b);


    class XSC_XML_Handlers_Export PlanLocality : public ::XSCRT::Type
    {
      using Base = ::XSCRT::Type;

      // constraint
      public:
      ::DAnCE::Config_Handlers::PlanLocalityKind const& constraint () const;
      void constraint (::DAnCE::Config_Handlers::PlanLocalityKind const& );

      protected:
      using constraint_unique_ptr_type = std::unique_ptr< ::DAnCE::Config_Handlers::PlanLocalityKind>;
      constraint_unique_ptr_type constraint_;

      // constrainedInstance
      public:
      using constrainedInstance_container_type = std::vector< ::DAnCE::Config_Handlers::IdRef>;
      using constrainedInstance_const_iterator = constrainedInstance_container_type::const_iterator;
      constrainedInstance_const_iterator begin_constrainedInstance () const;
      constrainedInstance_const_iterator end_constrainedInstance () const;
      size_t count_constrainedInstance () const;

      protected:
      constrainedInstance_container_type constrainedInstance_;

      public:
      PlanLocality (::DAnCE::Config_Handlers::PlanLocalityKind const& constraint__,
                    constrainedInstance_container_type const& constrainedInstance__);

      explicit PlanLocality (::XSCRT::XML::Element<char> const&);
      PlanLocality (PlanLocality const& s);
      PlanLocality& operator= (PlanLocality const& s);

      PlanLocality (PlanLocality&&) = default;
      PlanLocality& operator= (PlanLocality&&) = default;
    };
  }
}

namespace DAnCE
{
  namespace Config_Handlers
  {
  }
}

#endif // BASIC_DEPLOYMENT_DATA_HPP
