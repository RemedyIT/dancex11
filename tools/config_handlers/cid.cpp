/*
 * This code was generated by the XML Schema Compiler.
 *
 * Changes made to this code will most likely be overwritten
 * when the handlers are recompiled.
 */
#include "cid.hpp"

namespace DAnCE
{
  namespace Config_Handlers
  {
    // ComponentPackageReference

    ComponentPackageReference::ComponentPackageReference (::DAnCE::Config_Handlers::ComponentInterfaceDescription const& requiredType__)
    : ::XSCRT::Type ()
    , requiredType_ (std::make_unique<::DAnCE::Config_Handlers::ComponentInterfaceDescription> (requiredType__))
    {
    }

    ComponentPackageReference::ComponentPackageReference (ComponentPackageReference const& s) :
    ::XSCRT::Type (s)
    , requiredUUID_ (s.requiredUUID_ ? std::make_unique<::XMLSchema::string<char>> (*s.requiredUUID_) : nullptr)
    , requiredName_ (s.requiredName_ ? std::make_unique<::XMLSchema::string<char>> (*s.requiredName_) : nullptr)
    , requiredType_ (std::make_unique<::DAnCE::Config_Handlers::ComponentInterfaceDescription> (*s.requiredType_))
    {
    }

    ComponentPackageReference&
    ComponentPackageReference::operator= (ComponentPackageReference const& s)
    {
      if (std::addressof(s) != this)
      {
        if (s.requiredUUID_)
          requiredUUID (*(s.requiredUUID_));
        else
          requiredUUID_.reset (nullptr);

        if (s.requiredName_)
          requiredName (*(s.requiredName_));
        else
          requiredName_.reset (nullptr);

        requiredType (*s.requiredType_);
      }

      return *this;
    }


    // ComponentPackageReference
    bool ComponentPackageReference::
    requiredUUID_p () const
    {
      return !!requiredUUID_;
    }

    ::XMLSchema::string<char> const& ComponentPackageReference::
    requiredUUID () const
    {
      return *requiredUUID_;
    }

    void ComponentPackageReference::
    requiredUUID (::XMLSchema::string<char> const& e)
    {
      if (requiredUUID_)
      {
        *requiredUUID_ = e;
      }

      else
      {
        requiredUUID_ = std::make_unique<::XMLSchema::string<char>> (e);
      }
    }

    // ComponentPackageReference
    bool ComponentPackageReference::
    requiredName_p () const
    {
      return !!requiredName_;
    }

    ::XMLSchema::string<char> const& ComponentPackageReference::
    requiredName () const
    {
      return *requiredName_;
    }

    void ComponentPackageReference::
    requiredName (::XMLSchema::string<char> const& e)
    {
      if (requiredName_)
      {
        *requiredName_ = e;
      }

      else
      {
        requiredName_ = std::make_unique<::XMLSchema::string<char>> (e);
      }
    }

    // ComponentPackageReference
    ::DAnCE::Config_Handlers::ComponentInterfaceDescription const& ComponentPackageReference::
    requiredType () const
    {
      return *requiredType_;
    }

    void ComponentPackageReference::
    requiredType (::DAnCE::Config_Handlers::ComponentInterfaceDescription const& e)
    {
      *requiredType_ = e;
    }


    // SubcomponentInstantiationDescription

    SubcomponentInstantiationDescription::SubcomponentInstantiationDescription (::XMLSchema::string<char> const& name__)
    : ::XSCRT::Type ()
    , name_ (std::make_unique<::XMLSchema::string<char>> (name__))
    {
    }

    SubcomponentInstantiationDescription::SubcomponentInstantiationDescription (SubcomponentInstantiationDescription const& s) :
    ::XSCRT::Type (s)
    , name_ (std::make_unique<::XMLSchema::string<char>> (*s.name_))
    , basePackage_ (s.basePackage_ ? std::make_unique<::DAnCE::Config_Handlers::ComponentPackageDescription> (*s.basePackage_) : nullptr)
    , specializedConfig_ (s.specializedConfig_ ? std::make_unique<::DAnCE::Config_Handlers::PackageConfiguration> (*s.specializedConfig_) : nullptr)
    , selectRequirement_ (s.selectRequirement_)
    , configProperty_ (s.configProperty_)
    , referencedPackage_ (s.referencedPackage_ ? std::make_unique<::DAnCE::Config_Handlers::ComponentPackageReference> (*s.referencedPackage_) : nullptr)
    , importedPackage_ (s.importedPackage_ ? std::make_unique<::DAnCE::Config_Handlers::ComponentPackageImport> (*s.importedPackage_) : nullptr)
    , id_ (s.id_ ? std::make_unique<::XMLSchema::ID<char>> (*s.id_) : nullptr)
    {
    }

    SubcomponentInstantiationDescription&
    SubcomponentInstantiationDescription::operator= (SubcomponentInstantiationDescription const& s)
    {
      if (std::addressof(s) != this)
      {
        name (*s.name_);

        if (s.basePackage_)
          basePackage (*(s.basePackage_));
        else
          basePackage_.reset (nullptr);

        if (s.specializedConfig_)
          specializedConfig (*(s.specializedConfig_));
        else
          specializedConfig_.reset (nullptr);

        selectRequirement_ = s.selectRequirement_;

        configProperty_ = s.configProperty_;

        if (s.referencedPackage_)
          referencedPackage (*(s.referencedPackage_));
        else
          referencedPackage_.reset (nullptr);

        if (s.importedPackage_)
          importedPackage (*(s.importedPackage_));
        else
          importedPackage_.reset (nullptr);

        if (s.id_) id (*(s.id_));
        else id_.reset (nullptr);
      }

      return *this;
    }


    // SubcomponentInstantiationDescription
    ::XMLSchema::string<char> const& SubcomponentInstantiationDescription::
    name () const
    {
      return *name_;
    }

    void SubcomponentInstantiationDescription::
    name (::XMLSchema::string<char> const& e)
    {
      *name_ = e;
    }

    // SubcomponentInstantiationDescription
    bool SubcomponentInstantiationDescription::
    basePackage_p () const
    {
      return !!basePackage_;
    }

    ::DAnCE::Config_Handlers::ComponentPackageDescription const& SubcomponentInstantiationDescription::
    basePackage () const
    {
      return *basePackage_;
    }

    void SubcomponentInstantiationDescription::
    basePackage (::DAnCE::Config_Handlers::ComponentPackageDescription const& e)
    {
      if (basePackage_)
      {
        *basePackage_ = e;
      }

      else
      {
        basePackage_ = std::make_unique<::DAnCE::Config_Handlers::ComponentPackageDescription> (e);
      }
    }

    // SubcomponentInstantiationDescription
    bool SubcomponentInstantiationDescription::
    specializedConfig_p () const
    {
      return !!specializedConfig_;
    }

    ::DAnCE::Config_Handlers::PackageConfiguration const& SubcomponentInstantiationDescription::
    specializedConfig () const
    {
      return *specializedConfig_;
    }

    void SubcomponentInstantiationDescription::
    specializedConfig (::DAnCE::Config_Handlers::PackageConfiguration const& e)
    {
      if (specializedConfig_)
      {
        *specializedConfig_ = e;
      }

      else
      {
        specializedConfig_ = std::make_unique<::DAnCE::Config_Handlers::PackageConfiguration> (e);
      }
    }

    // SubcomponentInstantiationDescription
    SubcomponentInstantiationDescription::selectRequirement_const_iterator SubcomponentInstantiationDescription::
    begin_selectRequirement () const
    {
      return selectRequirement_.cbegin ();
    }

    SubcomponentInstantiationDescription::selectRequirement_const_iterator SubcomponentInstantiationDescription::
    end_selectRequirement () const
    {
      return selectRequirement_.cend ();
    }

    size_t SubcomponentInstantiationDescription::
    count_selectRequirement() const
    {
      return selectRequirement_.size ();
    }

    // SubcomponentInstantiationDescription
    SubcomponentInstantiationDescription::configProperty_const_iterator SubcomponentInstantiationDescription::
    begin_configProperty () const
    {
      return configProperty_.cbegin ();
    }

    SubcomponentInstantiationDescription::configProperty_const_iterator SubcomponentInstantiationDescription::
    end_configProperty () const
    {
      return configProperty_.cend ();
    }

    size_t SubcomponentInstantiationDescription::
    count_configProperty() const
    {
      return configProperty_.size ();
    }

    // SubcomponentInstantiationDescription
    bool SubcomponentInstantiationDescription::
    referencedPackage_p () const
    {
      return !!referencedPackage_;
    }

    ::DAnCE::Config_Handlers::ComponentPackageReference const& SubcomponentInstantiationDescription::
    referencedPackage () const
    {
      return *referencedPackage_;
    }

    void SubcomponentInstantiationDescription::
    referencedPackage (::DAnCE::Config_Handlers::ComponentPackageReference const& e)
    {
      if (referencedPackage_)
      {
        *referencedPackage_ = e;
      }

      else
      {
        referencedPackage_ = std::make_unique<::DAnCE::Config_Handlers::ComponentPackageReference> (e);
      }
    }

    // SubcomponentInstantiationDescription
    bool SubcomponentInstantiationDescription::
    importedPackage_p () const
    {
      return !!importedPackage_;
    }

    ::DAnCE::Config_Handlers::ComponentPackageImport const& SubcomponentInstantiationDescription::
    importedPackage () const
    {
      return *importedPackage_;
    }

    void SubcomponentInstantiationDescription::
    importedPackage (::DAnCE::Config_Handlers::ComponentPackageImport const& e)
    {
      if (importedPackage_)
      {
        *importedPackage_ = e;
      }

      else
      {
        importedPackage_ = std::make_unique<::DAnCE::Config_Handlers::ComponentPackageImport> (e);
      }
    }

    // SubcomponentInstantiationDescription
    bool SubcomponentInstantiationDescription::
    id_p () const
    {
      return !!id_;
    }

    ::XMLSchema::ID<char> const& SubcomponentInstantiationDescription::
    id () const
    {
      return *id_;
    }

    ::XMLSchema::ID<char>& SubcomponentInstantiationDescription::
    id ()
    {
      return *id_;
    }

    void SubcomponentInstantiationDescription::
    id (::XMLSchema::ID<char> const& e)
    {
      if (id_)
      {
        *id_ = e;
      }

      else
      {
        id_ = std::make_unique<::XMLSchema::ID<char>> (e);
      }
    }


    // SubcomponentPropertyReference

    SubcomponentPropertyReference::SubcomponentPropertyReference (::XMLSchema::string<char> const& propertyName__,
                                                                  ::DAnCE::Config_Handlers::IdRef const& instance__)
    : ::XSCRT::Type ()
    , propertyName_ (std::make_unique<::XMLSchema::string<char>> (propertyName__))
    , instance_ (std::make_unique<::DAnCE::Config_Handlers::IdRef> (instance__))
    {
    }

    SubcomponentPropertyReference::SubcomponentPropertyReference (SubcomponentPropertyReference const& s) :
    ::XSCRT::Type (s)
    , propertyName_ (std::make_unique<::XMLSchema::string<char>> (*s.propertyName_))
    , instance_ (std::make_unique<::DAnCE::Config_Handlers::IdRef> (*s.instance_))
    {
    }

    SubcomponentPropertyReference&
    SubcomponentPropertyReference::operator= (SubcomponentPropertyReference const& s)
    {
      if (std::addressof(s) != this)
      {
        propertyName (*s.propertyName_);

        instance (*s.instance_);
      }

      return *this;
    }


    // SubcomponentPropertyReference
    ::XMLSchema::string<char> const& SubcomponentPropertyReference::
    propertyName () const
    {
      return *propertyName_;
    }

    void SubcomponentPropertyReference::
    propertyName (::XMLSchema::string<char> const& e)
    {
      *propertyName_ = e;
    }

    // SubcomponentPropertyReference
    ::DAnCE::Config_Handlers::IdRef const& SubcomponentPropertyReference::
    instance () const
    {
      return *instance_;
    }

    void SubcomponentPropertyReference::
    instance (::DAnCE::Config_Handlers::IdRef const& e)
    {
      *instance_ = e;
    }


    // AssemblyPropertyMapping

    AssemblyPropertyMapping::AssemblyPropertyMapping (::XMLSchema::string<char> const& name__,
                                                      ::XMLSchema::string<char> const& externalName__)
    : ::XSCRT::Type ()
    , name_ (std::make_unique<::XMLSchema::string<char>> (name__))
    , externalName_ (std::make_unique<::XMLSchema::string<char>> (externalName__))
    {
    }

    AssemblyPropertyMapping::AssemblyPropertyMapping (AssemblyPropertyMapping const& s) :
    ::XSCRT::Type (s)
    , name_ (std::make_unique<::XMLSchema::string<char>> (*s.name_))
    , externalName_ (std::make_unique<::XMLSchema::string<char>> (*s.externalName_))
    , delegatesTo_ (s.delegatesTo_)
    {
    }

    AssemblyPropertyMapping&
    AssemblyPropertyMapping::operator= (AssemblyPropertyMapping const& s)
    {
      if (std::addressof(s) != this)
      {
        name (*s.name_);

        externalName (*s.externalName_);

        delegatesTo_ = s.delegatesTo_;
      }

      return *this;
    }


    // AssemblyPropertyMapping
    ::XMLSchema::string<char> const& AssemblyPropertyMapping::
    name () const
    {
      return *name_;
    }

    void AssemblyPropertyMapping::
    name (::XMLSchema::string<char> const& e)
    {
      *name_ = e;
    }

    // AssemblyPropertyMapping
    ::XMLSchema::string<char> const& AssemblyPropertyMapping::
    externalName () const
    {
      return *externalName_;
    }

    void AssemblyPropertyMapping::
    externalName (::XMLSchema::string<char> const& e)
    {
      *externalName_ = e;
    }

    // AssemblyPropertyMapping
    AssemblyPropertyMapping::delegatesTo_const_iterator AssemblyPropertyMapping::
    begin_delegatesTo () const
    {
      return delegatesTo_.cbegin ();
    }

    AssemblyPropertyMapping::delegatesTo_const_iterator AssemblyPropertyMapping::
    end_delegatesTo () const
    {
      return delegatesTo_.cend ();
    }

    size_t AssemblyPropertyMapping::
    count_delegatesTo() const
    {
      return delegatesTo_.size ();
    }


    // LocalityKind

    LocalityKind::Value LocalityKind::
    integral () const
    {
      return v_;
    }

    bool
    operator== (::DAnCE::Config_Handlers::LocalityKind const& a, ::DAnCE::Config_Handlers::LocalityKind const& b)
    {
      return a.v_ == b.v_;
    }

    bool
    operator!= (::DAnCE::Config_Handlers::LocalityKind const& a, ::DAnCE::Config_Handlers::LocalityKind const& b)
    {
      return a.v_ != b.v_;
    }

    LocalityKind::
    LocalityKind (LocalityKind::Value v)
    : v_ (v)
    {
    }

    // Locality

    Locality::Locality (::DAnCE::Config_Handlers::LocalityKind const& constraint__,
                        ::DAnCE::Config_Handlers::IdRef const& constrainedInstance__)
    : ::XSCRT::Type ()
    , constraint_ (std::make_unique<::DAnCE::Config_Handlers::LocalityKind> (constraint__))
    , constrainedInstance_ (std::make_unique<::DAnCE::Config_Handlers::IdRef> (constrainedInstance__))
    {
    }

    Locality::Locality (Locality const& s) :
    ::XSCRT::Type (s)
    , constraint_ (std::make_unique<::DAnCE::Config_Handlers::LocalityKind> (*s.constraint_))
    , constrainedInstance_ (std::make_unique<::DAnCE::Config_Handlers::IdRef> (*s.constrainedInstance_))
    {
    }

    Locality&
    Locality::operator= (Locality const& s)
    {
      if (std::addressof(s) != this)
      {
        constraint (*s.constraint_);

        constrainedInstance (*s.constrainedInstance_);
      }

      return *this;
    }


    // Locality
    ::DAnCE::Config_Handlers::LocalityKind const& Locality::
    constraint () const
    {
      return *constraint_;
    }

    void Locality::
    constraint (::DAnCE::Config_Handlers::LocalityKind const& e)
    {
      *constraint_ = e;
    }

    // Locality
    ::DAnCE::Config_Handlers::IdRef const& Locality::
    constrainedInstance () const
    {
      return *constrainedInstance_;
    }

    void Locality::
    constrainedInstance (::DAnCE::Config_Handlers::IdRef const& e)
    {
      *constrainedInstance_ = e;
    }


    // ComponentAssemblyDescription

    ComponentAssemblyDescription::ComponentAssemblyDescription ()
    : ::XSCRT::Type ()
    {
    }

    ComponentAssemblyDescription::ComponentAssemblyDescription (ComponentAssemblyDescription const& s) :
    ::XSCRT::Type (s)
    , instance_ (s.instance_)
    , connection_ (s.connection_)
    , externalProperty_ (s.externalProperty_)
    , locality_ (s.locality_)
    {
    }

    ComponentAssemblyDescription&
    ComponentAssemblyDescription::operator= (ComponentAssemblyDescription const& s)
    {
      if (std::addressof(s) != this)
      {
        instance_ = s.instance_;

        connection_ = s.connection_;

        externalProperty_ = s.externalProperty_;

        locality_ = s.locality_;
      }

      return *this;
    }


    // ComponentAssemblyDescription
    ComponentAssemblyDescription::instance_const_iterator ComponentAssemblyDescription::
    begin_instance () const
    {
      return instance_.cbegin ();
    }

    ComponentAssemblyDescription::instance_const_iterator ComponentAssemblyDescription::
    end_instance () const
    {
      return instance_.cend ();
    }

    size_t ComponentAssemblyDescription::
    count_instance() const
    {
      return instance_.size ();
    }

    // ComponentAssemblyDescription
    ComponentAssemblyDescription::connection_const_iterator ComponentAssemblyDescription::
    begin_connection () const
    {
      return connection_.cbegin ();
    }

    ComponentAssemblyDescription::connection_const_iterator ComponentAssemblyDescription::
    end_connection () const
    {
      return connection_.cend ();
    }

    size_t ComponentAssemblyDescription::
    count_connection() const
    {
      return connection_.size ();
    }

    // ComponentAssemblyDescription
    ComponentAssemblyDescription::externalProperty_const_iterator ComponentAssemblyDescription::
    begin_externalProperty () const
    {
      return externalProperty_.cbegin ();
    }

    ComponentAssemblyDescription::externalProperty_const_iterator ComponentAssemblyDescription::
    end_externalProperty () const
    {
      return externalProperty_.cend ();
    }

    size_t ComponentAssemblyDescription::
    count_externalProperty() const
    {
      return externalProperty_.size ();
    }

    // ComponentAssemblyDescription
    ComponentAssemblyDescription::locality_const_iterator ComponentAssemblyDescription::
    begin_locality () const
    {
      return locality_.cbegin ();
    }

    ComponentAssemblyDescription::locality_const_iterator ComponentAssemblyDescription::
    end_locality () const
    {
      return locality_.cend ();
    }

    size_t ComponentAssemblyDescription::
    count_locality() const
    {
      return locality_.size ();
    }


    // MonolithicImplementationDescription

    MonolithicImplementationDescription::MonolithicImplementationDescription ()
    : ::XSCRT::Type ()
    {
    }

    MonolithicImplementationDescription::MonolithicImplementationDescription (MonolithicImplementationDescription const& s) :
    ::XSCRT::Type (s)
    , nodeExecParameter_ (s.nodeExecParameter_)
    , componentExecParameter_ (s.componentExecParameter_)
    , deployRequirement_ (s.deployRequirement_)
    , primaryArtifact_ (s.primaryArtifact_)
    {
    }

    MonolithicImplementationDescription&
    MonolithicImplementationDescription::operator= (MonolithicImplementationDescription const& s)
    {
      if (std::addressof(s) != this)
      {
        nodeExecParameter_ = s.nodeExecParameter_;

        componentExecParameter_ = s.componentExecParameter_;

        deployRequirement_ = s.deployRequirement_;

        primaryArtifact_ = s.primaryArtifact_;
      }

      return *this;
    }


    // MonolithicImplementationDescription
    MonolithicImplementationDescription::nodeExecParameter_const_iterator MonolithicImplementationDescription::
    begin_nodeExecParameter () const
    {
      return nodeExecParameter_.cbegin ();
    }

    MonolithicImplementationDescription::nodeExecParameter_const_iterator MonolithicImplementationDescription::
    end_nodeExecParameter () const
    {
      return nodeExecParameter_.cend ();
    }

    size_t MonolithicImplementationDescription::
    count_nodeExecParameter() const
    {
      return nodeExecParameter_.size ();
    }

    // MonolithicImplementationDescription
    MonolithicImplementationDescription::componentExecParameter_const_iterator MonolithicImplementationDescription::
    begin_componentExecParameter () const
    {
      return componentExecParameter_.cbegin ();
    }

    MonolithicImplementationDescription::componentExecParameter_const_iterator MonolithicImplementationDescription::
    end_componentExecParameter () const
    {
      return componentExecParameter_.cend ();
    }

    size_t MonolithicImplementationDescription::
    count_componentExecParameter() const
    {
      return componentExecParameter_.size ();
    }

    // MonolithicImplementationDescription
    MonolithicImplementationDescription::deployRequirement_const_iterator MonolithicImplementationDescription::
    begin_deployRequirement () const
    {
      return deployRequirement_.cbegin ();
    }

    MonolithicImplementationDescription::deployRequirement_const_iterator MonolithicImplementationDescription::
    end_deployRequirement () const
    {
      return deployRequirement_.cend ();
    }

    size_t MonolithicImplementationDescription::
    count_deployRequirement() const
    {
      return deployRequirement_.size ();
    }

    // MonolithicImplementationDescription
    MonolithicImplementationDescription::primaryArtifact_const_iterator MonolithicImplementationDescription::
    begin_primaryArtifact () const
    {
      return primaryArtifact_.cbegin ();
    }

    MonolithicImplementationDescription::primaryArtifact_const_iterator MonolithicImplementationDescription::
    end_primaryArtifact () const
    {
      return primaryArtifact_.cend ();
    }

    size_t MonolithicImplementationDescription::
    count_primaryArtifact() const
    {
      return primaryArtifact_.size ();
    }


    // ComponentImplementationDescription

    ComponentImplementationDescription::ComponentImplementationDescription ()
    : ::XSCRT::Type ()
    {
    }

    ComponentImplementationDescription::ComponentImplementationDescription (ComponentImplementationDescription const& s) :
    ::XSCRT::Type (s)
    , label_ (s.label_ ? std::make_unique<::XMLSchema::string<char>> (*s.label_) : nullptr)
    , UUID_ (s.UUID_ ? std::make_unique<::XMLSchema::string<char>> (*s.UUID_) : nullptr)
    , implements_ (s.implements_ ? std::make_unique<::DAnCE::Config_Handlers::ComponentInterfaceDescription> (*s.implements_) : nullptr)
    , assemblyImpl_ (s.assemblyImpl_ ? std::make_unique<::DAnCE::Config_Handlers::ComponentAssemblyDescription> (*s.assemblyImpl_) : nullptr)
    , monolithicImpl_ (s.monolithicImpl_ ? std::make_unique<::DAnCE::Config_Handlers::MonolithicImplementationDescription> (*s.monolithicImpl_) : nullptr)
    , configProperty_ (s.configProperty_)
    , capability_ (s.capability_)
    , dependsOn_ (s.dependsOn_)
    , infoProperty_ (s.infoProperty_)
    , href_ (s.href_ ? std::make_unique<::XMLSchema::string<char>> (*s.href_) : nullptr)
    {
    }

    ComponentImplementationDescription&
    ComponentImplementationDescription::operator= (ComponentImplementationDescription const& s)
    {
      if (std::addressof(s) != this)
      {
        if (s.label_)
          label (*(s.label_));
        else
          label_.reset (nullptr);

        if (s.UUID_)
          UUID (*(s.UUID_));
        else
          UUID_.reset (nullptr);

        if (s.implements_)
          implements (*(s.implements_));
        else
          implements_.reset (nullptr);

        if (s.assemblyImpl_)
          assemblyImpl (*(s.assemblyImpl_));
        else
          assemblyImpl_.reset (nullptr);

        if (s.monolithicImpl_)
          monolithicImpl (*(s.monolithicImpl_));
        else
          monolithicImpl_.reset (nullptr);

        configProperty_ = s.configProperty_;

        capability_ = s.capability_;

        dependsOn_ = s.dependsOn_;

        infoProperty_ = s.infoProperty_;

        if (s.href_) href (*(s.href_));
        else href_.reset (nullptr);
      }

      return *this;
    }


    // ComponentImplementationDescription
    bool ComponentImplementationDescription::
    label_p () const
    {
      return !!label_;
    }

    ::XMLSchema::string<char> const& ComponentImplementationDescription::
    label () const
    {
      return *label_;
    }

    void ComponentImplementationDescription::
    label (::XMLSchema::string<char> const& e)
    {
      if (label_)
      {
        *label_ = e;
      }

      else
      {
        label_ = std::make_unique<::XMLSchema::string<char>> (e);
      }
    }

    // ComponentImplementationDescription
    bool ComponentImplementationDescription::
    UUID_p () const
    {
      return !!UUID_;
    }

    ::XMLSchema::string<char> const& ComponentImplementationDescription::
    UUID () const
    {
      return *UUID_;
    }

    void ComponentImplementationDescription::
    UUID (::XMLSchema::string<char> const& e)
    {
      if (UUID_)
      {
        *UUID_ = e;
      }

      else
      {
        UUID_ = std::make_unique<::XMLSchema::string<char>> (e);
      }
    }

    // ComponentImplementationDescription
    bool ComponentImplementationDescription::
    implements_p () const
    {
      return !!implements_;
    }

    ::DAnCE::Config_Handlers::ComponentInterfaceDescription const& ComponentImplementationDescription::
    implements () const
    {
      return *implements_;
    }

    void ComponentImplementationDescription::
    implements (::DAnCE::Config_Handlers::ComponentInterfaceDescription const& e)
    {
      if (implements_)
      {
        *implements_ = e;
      }

      else
      {
        implements_ = std::make_unique<::DAnCE::Config_Handlers::ComponentInterfaceDescription> (e);
      }
    }

    // ComponentImplementationDescription
    bool ComponentImplementationDescription::
    assemblyImpl_p () const
    {
      return !!assemblyImpl_;
    }

    ::DAnCE::Config_Handlers::ComponentAssemblyDescription const& ComponentImplementationDescription::
    assemblyImpl () const
    {
      return *assemblyImpl_;
    }

    void ComponentImplementationDescription::
    assemblyImpl (::DAnCE::Config_Handlers::ComponentAssemblyDescription const& e)
    {
      if (assemblyImpl_)
      {
        *assemblyImpl_ = e;
      }

      else
      {
        assemblyImpl_ = std::make_unique<::DAnCE::Config_Handlers::ComponentAssemblyDescription> (e);
      }
    }

    // ComponentImplementationDescription
    bool ComponentImplementationDescription::
    monolithicImpl_p () const
    {
      return !!monolithicImpl_;
    }

    ::DAnCE::Config_Handlers::MonolithicImplementationDescription const& ComponentImplementationDescription::
    monolithicImpl () const
    {
      return *monolithicImpl_;
    }

    void ComponentImplementationDescription::
    monolithicImpl (::DAnCE::Config_Handlers::MonolithicImplementationDescription const& e)
    {
      if (monolithicImpl_)
      {
        *monolithicImpl_ = e;
      }

      else
      {
        monolithicImpl_ = std::make_unique<::DAnCE::Config_Handlers::MonolithicImplementationDescription> (e);
      }
    }

    // ComponentImplementationDescription
    ComponentImplementationDescription::configProperty_const_iterator ComponentImplementationDescription::
    begin_configProperty () const
    {
      return configProperty_.cbegin ();
    }

    ComponentImplementationDescription::configProperty_const_iterator ComponentImplementationDescription::
    end_configProperty () const
    {
      return configProperty_.cend ();
    }

    size_t ComponentImplementationDescription::
    count_configProperty() const
    {
      return configProperty_.size ();
    }

    // ComponentImplementationDescription
    ComponentImplementationDescription::capability_const_iterator ComponentImplementationDescription::
    begin_capability () const
    {
      return capability_.cbegin ();
    }

    ComponentImplementationDescription::capability_const_iterator ComponentImplementationDescription::
    end_capability () const
    {
      return capability_.cend ();
    }

    size_t ComponentImplementationDescription::
    count_capability() const
    {
      return capability_.size ();
    }

    // ComponentImplementationDescription
    ComponentImplementationDescription::dependsOn_const_iterator ComponentImplementationDescription::
    begin_dependsOn () const
    {
      return dependsOn_.cbegin ();
    }

    ComponentImplementationDescription::dependsOn_const_iterator ComponentImplementationDescription::
    end_dependsOn () const
    {
      return dependsOn_.cend ();
    }

    size_t ComponentImplementationDescription::
    count_dependsOn() const
    {
      return dependsOn_.size ();
    }

    // ComponentImplementationDescription
    ComponentImplementationDescription::infoProperty_const_iterator ComponentImplementationDescription::
    begin_infoProperty () const
    {
      return infoProperty_.cbegin ();
    }

    ComponentImplementationDescription::infoProperty_const_iterator ComponentImplementationDescription::
    end_infoProperty () const
    {
      return infoProperty_.cend ();
    }

    size_t ComponentImplementationDescription::
    count_infoProperty() const
    {
      return infoProperty_.size ();
    }

    // ComponentImplementationDescription
    bool ComponentImplementationDescription::
    href_p () const
    {
      return !!href_;
    }

    ::XMLSchema::string<char> const& ComponentImplementationDescription::
    href () const
    {
      return *href_;
    }

    ::XMLSchema::string<char>& ComponentImplementationDescription::
    href ()
    {
      return *href_;
    }

    void ComponentImplementationDescription::
    href (::XMLSchema::string<char> const& e)
    {
      if (href_)
      {
        *href_ = e;
      }

      else
      {
        href_ = std::make_unique<::XMLSchema::string<char>> (e);
      }
    }


    // ConnectorImplementationDescription

    ConnectorImplementationDescription::ConnectorImplementationDescription ()
    : ::XSCRT::Type ()
    {
    }

    ConnectorImplementationDescription::ConnectorImplementationDescription (ConnectorImplementationDescription const& s) :
    ::XSCRT::Type (s)
    , label_ (s.label_ ? std::make_unique<::XMLSchema::string<char>> (*s.label_) : nullptr)
    , UUID_ (s.UUID_ ? std::make_unique<::XMLSchema::string<char>> (*s.UUID_) : nullptr)
    , implements_ (s.implements_ ? std::make_unique<::DAnCE::Config_Handlers::ComponentInterfaceDescription> (*s.implements_) : nullptr)
    , assemblyImpl_ (s.assemblyImpl_ ? std::make_unique<::DAnCE::Config_Handlers::ComponentAssemblyDescription> (*s.assemblyImpl_) : nullptr)
    , monolithicImpl_ (s.monolithicImpl_ ? std::make_unique<::DAnCE::Config_Handlers::MonolithicImplementationDescription> (*s.monolithicImpl_) : nullptr)
    , configProperty_ (s.configProperty_)
    , capability_ (s.capability_)
    , dependsOn_ (s.dependsOn_)
    , infoProperty_ (s.infoProperty_)
    , href_ (s.href_ ? std::make_unique<::XMLSchema::string<char>> (*s.href_) : nullptr)
    {
    }

    ConnectorImplementationDescription&
    ConnectorImplementationDescription::operator= (ConnectorImplementationDescription const& s)
    {
      if (std::addressof(s) != this)
      {
        if (s.label_)
          label (*(s.label_));
        else
          label_.reset (nullptr);

        if (s.UUID_)
          UUID (*(s.UUID_));
        else
          UUID_.reset (nullptr);

        if (s.implements_)
          implements (*(s.implements_));
        else
          implements_.reset (nullptr);

        if (s.assemblyImpl_)
          assemblyImpl (*(s.assemblyImpl_));
        else
          assemblyImpl_.reset (nullptr);

        if (s.monolithicImpl_)
          monolithicImpl (*(s.monolithicImpl_));
        else
          monolithicImpl_.reset (nullptr);

        configProperty_ = s.configProperty_;

        capability_ = s.capability_;

        dependsOn_ = s.dependsOn_;

        infoProperty_ = s.infoProperty_;

        if (s.href_) href (*(s.href_));
        else href_.reset (nullptr);
      }

      return *this;
    }


    // ConnectorImplementationDescription
    bool ConnectorImplementationDescription::
    label_p () const
    {
      return !!label_;
    }

    ::XMLSchema::string<char> const& ConnectorImplementationDescription::
    label () const
    {
      return *label_;
    }

    void ConnectorImplementationDescription::
    label (::XMLSchema::string<char> const& e)
    {
      if (label_)
      {
        *label_ = e;
      }

      else
      {
        label_ = std::make_unique<::XMLSchema::string<char>> (e);
      }
    }

    // ConnectorImplementationDescription
    bool ConnectorImplementationDescription::
    UUID_p () const
    {
      return !!UUID_;
    }

    ::XMLSchema::string<char> const& ConnectorImplementationDescription::
    UUID () const
    {
      return *UUID_;
    }

    void ConnectorImplementationDescription::
    UUID (::XMLSchema::string<char> const& e)
    {
      if (UUID_)
      {
        *UUID_ = e;
      }

      else
      {
        UUID_ = std::make_unique<::XMLSchema::string<char>> (e);
      }
    }

    // ConnectorImplementationDescription
    bool ConnectorImplementationDescription::
    implements_p () const
    {
      return !!implements_;
    }

    ::DAnCE::Config_Handlers::ComponentInterfaceDescription const& ConnectorImplementationDescription::
    implements () const
    {
      return *implements_;
    }

    void ConnectorImplementationDescription::
    implements (::DAnCE::Config_Handlers::ComponentInterfaceDescription const& e)
    {
      if (implements_)
      {
        *implements_ = e;
      }

      else
      {
        implements_ = std::make_unique<::DAnCE::Config_Handlers::ComponentInterfaceDescription> (e);
      }
    }

    // ConnectorImplementationDescription
    bool ConnectorImplementationDescription::
    assemblyImpl_p () const
    {
      return !!assemblyImpl_;
    }

    ::DAnCE::Config_Handlers::ComponentAssemblyDescription const& ConnectorImplementationDescription::
    assemblyImpl () const
    {
      return *assemblyImpl_;
    }

    void ConnectorImplementationDescription::
    assemblyImpl (::DAnCE::Config_Handlers::ComponentAssemblyDescription const& e)
    {
      if (assemblyImpl_)
      {
        *assemblyImpl_ = e;
      }

      else
      {
        assemblyImpl_ = std::make_unique<::DAnCE::Config_Handlers::ComponentAssemblyDescription> (e);
      }
    }

    // ConnectorImplementationDescription
    bool ConnectorImplementationDescription::
    monolithicImpl_p () const
    {
      return !!monolithicImpl_;
    }

    ::DAnCE::Config_Handlers::MonolithicImplementationDescription const& ConnectorImplementationDescription::
    monolithicImpl () const
    {
      return *monolithicImpl_;
    }

    void ConnectorImplementationDescription::
    monolithicImpl (::DAnCE::Config_Handlers::MonolithicImplementationDescription const& e)
    {
      if (monolithicImpl_)
      {
        *monolithicImpl_ = e;
      }

      else
      {
        monolithicImpl_ = std::make_unique<::DAnCE::Config_Handlers::MonolithicImplementationDescription> (e);
      }
    }

    // ConnectorImplementationDescription
    ConnectorImplementationDescription::configProperty_const_iterator ConnectorImplementationDescription::
    begin_configProperty () const
    {
      return configProperty_.cbegin ();
    }

    ConnectorImplementationDescription::configProperty_const_iterator ConnectorImplementationDescription::
    end_configProperty () const
    {
      return configProperty_.cend ();
    }

    size_t ConnectorImplementationDescription::
    count_configProperty() const
    {
      return configProperty_.size ();
    }

    // ConnectorImplementationDescription
    ConnectorImplementationDescription::capability_const_iterator ConnectorImplementationDescription::
    begin_capability () const
    {
      return capability_.cbegin ();
    }

    ConnectorImplementationDescription::capability_const_iterator ConnectorImplementationDescription::
    end_capability () const
    {
      return capability_.cend ();
    }

    size_t ConnectorImplementationDescription::
    count_capability() const
    {
      return capability_.size ();
    }

    // ConnectorImplementationDescription
    ConnectorImplementationDescription::dependsOn_const_iterator ConnectorImplementationDescription::
    begin_dependsOn () const
    {
      return dependsOn_.cbegin ();
    }

    ConnectorImplementationDescription::dependsOn_const_iterator ConnectorImplementationDescription::
    end_dependsOn () const
    {
      return dependsOn_.cend ();
    }

    size_t ConnectorImplementationDescription::
    count_dependsOn() const
    {
      return dependsOn_.size ();
    }

    // ConnectorImplementationDescription
    ConnectorImplementationDescription::infoProperty_const_iterator ConnectorImplementationDescription::
    begin_infoProperty () const
    {
      return infoProperty_.cbegin ();
    }

    ConnectorImplementationDescription::infoProperty_const_iterator ConnectorImplementationDescription::
    end_infoProperty () const
    {
      return infoProperty_.cend ();
    }

    size_t ConnectorImplementationDescription::
    count_infoProperty() const
    {
      return infoProperty_.size ();
    }

    // ConnectorImplementationDescription
    bool ConnectorImplementationDescription::
    href_p () const
    {
      return !!href_;
    }

    ::XMLSchema::string<char> const& ConnectorImplementationDescription::
    href () const
    {
      return *href_;
    }

    ::XMLSchema::string<char>& ConnectorImplementationDescription::
    href ()
    {
      return *href_;
    }

    void ConnectorImplementationDescription::
    href (::XMLSchema::string<char> const& e)
    {
      if (href_)
      {
        *href_ = e;
      }

      else
      {
        href_ = std::make_unique<::XMLSchema::string<char>> (e);
      }
    }
  }
}

namespace DAnCE
{
  namespace Config_Handlers
  {
    // ComponentPackageReference

    ComponentPackageReference::
    ComponentPackageReference (::XSCRT::XML::Element<char> const& element)
    :Base (element)
    {

      ::XSCRT::Parser<char> p (element);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<char> e (p.next_element ());
        std::string n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "requiredUUID")
        {
          ::XMLSchema::string<char> t (e);
          requiredUUID (t);
        }

        else if (n == "requiredName")
        {
          ::XMLSchema::string<char> t (e);
          requiredName (t);
        }

        else if (n == "requiredType")
        {
          requiredType_ = std::make_unique<::DAnCE::Config_Handlers::ComponentInterfaceDescription> (e);
        }

        else 
        {
        }
      }
    }

    // SubcomponentInstantiationDescription

    SubcomponentInstantiationDescription::
    SubcomponentInstantiationDescription (::XSCRT::XML::Element<char> const& element)
    :Base (element)
    {

      ::XSCRT::Parser<char> p (element);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<char> e (p.next_element ());
        std::string n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "name")
        {
          name_ = std::make_unique<::XMLSchema::string<char>> (e);
        }

        else if (n == "basePackage")
        {
          ::DAnCE::Config_Handlers::ComponentPackageDescription t (e);
          basePackage (t);
        }

        else if (n == "specializedConfig")
        {
          ::DAnCE::Config_Handlers::PackageConfiguration t (e);
          specializedConfig (t);
        }

        else if (n == "selectRequirement")
        {
          ::DAnCE::Config_Handlers::Requirement t (e);
          selectRequirement_.push_back (t);
        }

        else if (n == "configProperty")
        {
          ::DAnCE::Config_Handlers::Property t (e);
          configProperty_.push_back (t);
        }

        else if (n == "referencedPackage")
        {
          ::DAnCE::Config_Handlers::ComponentPackageReference t (e);
          referencedPackage (t);
        }

        else if (n == "importedPackage")
        {
          ::DAnCE::Config_Handlers::ComponentPackageImport t (e);
          importedPackage (t);
        }

        else 
        {
        }
      }

      while (p.more_attributes ())
      {
        ::XSCRT::XML::Attribute<char> a (p.next_attribute ());
        std::string n (::XSCRT::XML::uq_name (a.name ()));
        if (n ==  ("id"))
        {
          ::XMLSchema::ID<char> t (a);
          id (t);
        }

        else 
        {
        }
      }
    }

    // SubcomponentPropertyReference

    SubcomponentPropertyReference::
    SubcomponentPropertyReference (::XSCRT::XML::Element<char> const& element)
    :Base (element)
    {

      ::XSCRT::Parser<char> p (element);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<char> e (p.next_element ());
        std::string n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "propertyName")
        {
          propertyName_ = std::make_unique<::XMLSchema::string<char>> (e);
        }

        else if (n == "instance")
        {
          instance_ = std::make_unique<::DAnCE::Config_Handlers::IdRef> (e);
        }

        else 
        {
        }
      }
    }

    // AssemblyPropertyMapping

    AssemblyPropertyMapping::
    AssemblyPropertyMapping (::XSCRT::XML::Element<char> const& element)
    :Base (element)
    {

      ::XSCRT::Parser<char> p (element);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<char> e (p.next_element ());
        std::string n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "name")
        {
          name_ = std::make_unique<::XMLSchema::string<char>> (e);
        }

        else if (n == "externalName")
        {
          externalName_ = std::make_unique<::XMLSchema::string<char>> (e);
        }

        else if (n == "delegatesTo")
        {
          ::DAnCE::Config_Handlers::SubcomponentPropertyReference t (e);
          delegatesTo_.push_back (t);
        }

        else 
        {
        }
      }
    }

    // LocalityKind

    LocalityKind::
    LocalityKind (::XSCRT::XML::Element<char> const& e)
    : ::XSCRT::Type (e)
    {
      std::string v (e.value ());

      if (v ==  ("SameNodeAnyProcess")) v_ = SameNodeAnyProcess_l;
      else if (v ==  ("SameNodeSameProcess")) v_ = SameNodeSameProcess_l;
      else if (v ==  ("SameNodeDifferentProcess")) v_ = SameNodeDifferentProcess_l;
      else if (v ==  ("DifferentNode")) v_ = DifferentNode_l;
      else if (v ==  ("DifferentProcess")) v_ = DifferentProcess_l;
      else if (v ==  ("NoConstraint")) v_ = NoConstraint_l;
      else 
      {
      }
    }

    LocalityKind::
    LocalityKind (::XSCRT::XML::Attribute<char> const& a)
    : ::XSCRT::Type (a)
    {
      std::string v (a.value ());

      if (v ==  ("SameNodeAnyProcess")) v_ = SameNodeAnyProcess_l;
      else if (v ==  ("SameNodeSameProcess")) v_ = SameNodeSameProcess_l;
      else if (v ==  ("SameNodeDifferentProcess")) v_ = SameNodeDifferentProcess_l;
      else if (v ==  ("DifferentNode")) v_ = DifferentNode_l;
      else if (v ==  ("DifferentProcess")) v_ = DifferentProcess_l;
      else if (v ==  ("NoConstraint")) v_ = NoConstraint_l;
      else 
      {
      }
    }

    LocalityKind const LocalityKind::SameNodeAnyProcess (LocalityKind::SameNodeAnyProcess_l);
    LocalityKind const LocalityKind::SameNodeSameProcess (LocalityKind::SameNodeSameProcess_l);
    LocalityKind const LocalityKind::SameNodeDifferentProcess (LocalityKind::SameNodeDifferentProcess_l);
    LocalityKind const LocalityKind::DifferentNode (LocalityKind::DifferentNode_l);
    LocalityKind const LocalityKind::DifferentProcess (LocalityKind::DifferentProcess_l);
    LocalityKind const LocalityKind::NoConstraint (LocalityKind::NoConstraint_l);

    // Locality

    Locality::
    Locality (::XSCRT::XML::Element<char> const& element)
    :Base (element)
    {

      ::XSCRT::Parser<char> p (element);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<char> e (p.next_element ());
        std::string n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "constraint")
        {
          constraint_ = std::make_unique<::DAnCE::Config_Handlers::LocalityKind> (e);
        }

        else if (n == "constrainedInstance")
        {
          constrainedInstance_ = std::make_unique<::DAnCE::Config_Handlers::IdRef> (e);
        }

        else 
        {
        }
      }
    }

    // ComponentAssemblyDescription

    ComponentAssemblyDescription::
    ComponentAssemblyDescription (::XSCRT::XML::Element<char> const& element)
    :Base (element)
    {

      ::XSCRT::Parser<char> p (element);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<char> e (p.next_element ());
        std::string n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "instance")
        {
          ::DAnCE::Config_Handlers::SubcomponentInstantiationDescription t (e);
          instance_.push_back (t);
        }

        else if (n == "connection")
        {
          ::DAnCE::Config_Handlers::AssemblyConnectionDescription t (e);
          connection_.push_back (t);
        }

        else if (n == "externalProperty")
        {
          ::DAnCE::Config_Handlers::AssemblyPropertyMapping t (e);
          externalProperty_.push_back (t);
        }

        else if (n == "locality")
        {
          ::DAnCE::Config_Handlers::Locality t (e);
          locality_.push_back (t);
        }

        else 
        {
        }
      }
    }

    // MonolithicImplementationDescription

    MonolithicImplementationDescription::
    MonolithicImplementationDescription (::XSCRT::XML::Element<char> const& element)
    :Base (element)
    {

      ::XSCRT::Parser<char> p (element);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<char> e (p.next_element ());
        std::string n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "nodeExecParameter")
        {
          ::DAnCE::Config_Handlers::Property t (e);
          nodeExecParameter_.push_back (t);
        }

        else if (n == "componentExecParameter")
        {
          ::DAnCE::Config_Handlers::Property t (e);
          componentExecParameter_.push_back (t);
        }

        else if (n == "deployRequirement")
        {
          ::DAnCE::Config_Handlers::ImplementationRequirement t (e);
          deployRequirement_.push_back (t);
        }

        else if (n == "primaryArtifact")
        {
          ::DAnCE::Config_Handlers::NamedImplementationArtifact t (e);
          primaryArtifact_.push_back (t);
        }

        else 
        {
        }
      }
    }

    // ComponentImplementationDescription

    ComponentImplementationDescription::
    ComponentImplementationDescription (::XSCRT::XML::Element<char> const& element)
    :Base (element)
    {

      ::XSCRT::Parser<char> p (element);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<char> e (p.next_element ());
        std::string n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "label")
        {
          ::XMLSchema::string<char> t (e);
          label (t);
        }

        else if (n == "UUID")
        {
          ::XMLSchema::string<char> t (e);
          UUID (t);
        }

        else if (n == "implements")
        {
          ::DAnCE::Config_Handlers::ComponentInterfaceDescription t (e);
          implements (t);
        }

        else if (n == "assemblyImpl")
        {
          ::DAnCE::Config_Handlers::ComponentAssemblyDescription t (e);
          assemblyImpl (t);
        }

        else if (n == "monolithicImpl")
        {
          ::DAnCE::Config_Handlers::MonolithicImplementationDescription t (e);
          monolithicImpl (t);
        }

        else if (n == "configProperty")
        {
          ::DAnCE::Config_Handlers::Property t (e);
          configProperty_.push_back (t);
        }

        else if (n == "capability")
        {
          ::DAnCE::Config_Handlers::Capability t (e);
          capability_.push_back (t);
        }

        else if (n == "dependsOn")
        {
          ::DAnCE::Config_Handlers::ImplementationDependency t (e);
          dependsOn_.push_back (t);
        }

        else if (n == "infoProperty")
        {
          ::DAnCE::Config_Handlers::Property t (e);
          infoProperty_.push_back (t);
        }

        else 
        {
        }
      }

      while (p.more_attributes ())
      {
        ::XSCRT::XML::Attribute<char> a (p.next_attribute ());
        std::string n (::XSCRT::XML::uq_name (a.name ()));
        if (n ==  ("href"))
        {
          ::XMLSchema::string<char> t (a);
          href (t);
        }

        else 
        {
        }
      }
    }

    // ConnectorImplementationDescription

    ConnectorImplementationDescription::
    ConnectorImplementationDescription (::XSCRT::XML::Element<char> const& element)
    :Base (element)
    {

      ::XSCRT::Parser<char> p (element);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<char> e (p.next_element ());
        std::string n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "label")
        {
          ::XMLSchema::string<char> t (e);
          label (t);
        }

        else if (n == "UUID")
        {
          ::XMLSchema::string<char> t (e);
          UUID (t);
        }

        else if (n == "implements")
        {
          ::DAnCE::Config_Handlers::ComponentInterfaceDescription t (e);
          implements (t);
        }

        else if (n == "assemblyImpl")
        {
          ::DAnCE::Config_Handlers::ComponentAssemblyDescription t (e);
          assemblyImpl (t);
        }

        else if (n == "monolithicImpl")
        {
          ::DAnCE::Config_Handlers::MonolithicImplementationDescription t (e);
          monolithicImpl (t);
        }

        else if (n == "configProperty")
        {
          ::DAnCE::Config_Handlers::Property t (e);
          configProperty_.push_back (t);
        }

        else if (n == "capability")
        {
          ::DAnCE::Config_Handlers::Capability t (e);
          capability_.push_back (t);
        }

        else if (n == "dependsOn")
        {
          ::DAnCE::Config_Handlers::ImplementationDependency t (e);
          dependsOn_.push_back (t);
        }

        else if (n == "infoProperty")
        {
          ::DAnCE::Config_Handlers::Property t (e);
          infoProperty_.push_back (t);
        }

        else 
        {
        }
      }

      while (p.more_attributes ())
      {
        ::XSCRT::XML::Attribute<char> a (p.next_attribute ());
        std::string n (::XSCRT::XML::uq_name (a.name ()));
        if (n ==  ("href"))
        {
          ::XMLSchema::string<char> t (a);
          href (t);
        }

        else 
        {
        }
      }
    }
  }
}

namespace DAnCE
{
  namespace Config_Handlers
  {
  }
}

