/*
 * This code was generated by the XML Schema Compiler.
 *
 * Changes made to this code will most likely be overwritten
 * when the handlers are recompiled.
 */
#include "Basic_Deployment_Data.hpp"

namespace DAnCE
{
  namespace Config_Handlers
  {
    // IdRef

    IdRef::IdRef ()
    {
    }

    IdRef::IdRef (IdRef const& s) :
    ::XSCRT::Type (s)
    , href_ (s.href_ ? std::make_unique<::XMLSchema::string<char>> (*s.href_) : nullptr)
    , idref_ (s.idref_ ? std::make_unique<::XMLSchema::IDREF<char>> (*s.idref_) : nullptr)
    {
    }

    IdRef&
    IdRef::operator= (IdRef const& s)
    {
      if (std::addressof(s) != this)
      {
        if (s.href_) href (*(s.href_));
        else href_.release ();

        if (s.idref_) idref (*(s.idref_));
        else idref_.release ();
      }

      return *this;
    }


    // IdRef
    bool IdRef::
    href_p () const
    {
      return !!href_;
    }

    ::XMLSchema::string<char> const& IdRef::
    href () const
    {
      return *href_;
    }

    ::XMLSchema::string<char>& IdRef::
    href ()
    {
      return *href_;
    }

    void IdRef::
    href (::XMLSchema::string<char> const& e)
    {
      if (href_)
      {
        *href_ = e;
      }

      else
      {
        href_ = std::make_unique<::XMLSchema::string<char>> (e);
      }
    }

    // IdRef
    bool IdRef::
    idref_p () const
    {
      return !!idref_;
    }

    ::XMLSchema::IDREF<char> const& IdRef::
    idref () const
    {
      return *idref_;
    }

    ::XMLSchema::IDREF<char>& IdRef::
    idref ()
    {
      return *idref_;
    }

    void IdRef::
    idref (::XMLSchema::IDREF<char> const& e)
    {
      if (idref_)
      {
        *idref_ = e;
      }

      else
      {
        idref_ = std::make_unique<::XMLSchema::IDREF<char>> (e);
      }
    }


    // TCKind

    TCKind::Value TCKind::
    integral () const
    {
      return v_;
    }

    bool
    operator== (::DAnCE::Config_Handlers::TCKind const& a, ::DAnCE::Config_Handlers::TCKind const& b)
    {
      return a.v_ == b.v_;
    }

    bool
    operator!= (::DAnCE::Config_Handlers::TCKind const& a, ::DAnCE::Config_Handlers::TCKind const& b)
    {
      return a.v_ != b.v_;
    }

    TCKind::
    TCKind (TCKind::Value v)
    : v_ (v)
    {
    }

    // DataType

    DataType::DataType (::DAnCE::Config_Handlers::TCKind const& kind__)
    : ::XSCRT::Type ()
    , kind_ (std::make_unique<::DAnCE::Config_Handlers::TCKind> (kind__))
    {
    }

    DataType::DataType (DataType const& s) :
    ::XSCRT::Type (s)
    , kind_ (std::make_unique<::DAnCE::Config_Handlers::TCKind> (*s.kind_))
    , enum__ (s.enum__ ? std::make_unique<::DAnCE::Config_Handlers::EnumType> (*s.enum__) : nullptr)
    , struct__ (s.struct__ ? std::make_unique<::DAnCE::Config_Handlers::StructType> (*s.struct__) : nullptr)
    , value_ (s.value_ ? std::make_unique<::DAnCE::Config_Handlers::ValueType> (*s.value_) : nullptr)
    , sequence_ (s.sequence_ ? std::make_unique<::DAnCE::Config_Handlers::SequenceType> (*s.sequence_) : nullptr)
    , alias_ (s.alias_ ? std::make_unique<::DAnCE::Config_Handlers::AliasType> (*s.alias_) : nullptr)
    , array_ (s.array_ ? std::make_unique<::DAnCE::Config_Handlers::ArrayType> (*s.array_) : nullptr)
    , boundedString_ (s.boundedString_ ? std::make_unique<::DAnCE::Config_Handlers::BoundedStringType> (*s.boundedString_) : nullptr)
    , id_ (s.id_ ? std::make_unique<::XMLSchema::ID<char>> (*s.id_) : nullptr)
    {
    }

    DataType&
    DataType::operator= (DataType const& s)
    {
      if (std::addressof(s) != this)
      {
        kind (*s.kind_);

        if (s.enum__)
          enum_ (*(s.enum__));
        else
          enum__.release ();

        if (s.struct__)
          struct_ (*(s.struct__));
        else
          struct__.release ();

        if (s.value_)
          value (*(s.value_));
        else
          value_.release ();

        if (s.sequence_)
          sequence (*(s.sequence_));
        else
          sequence_.release ();

        if (s.alias_)
          alias (*(s.alias_));
        else
          alias_.release ();

        if (s.array_)
          array (*(s.array_));
        else
          array_.release ();

        if (s.boundedString_)
          boundedString (*(s.boundedString_));
        else
          boundedString_.release ();

        if (s.id_) id (*(s.id_));
        else id_.release ();
      }

      return *this;
    }


    // DataType
    ::DAnCE::Config_Handlers::TCKind const& DataType::
    kind () const
    {
      return *kind_;
    }

    void DataType::
    kind (::DAnCE::Config_Handlers::TCKind const& e)
    {
      *kind_ = e;
    }

    // DataType
    bool DataType::
    enum_p () const
    {
      return !!enum__;
    }

    ::DAnCE::Config_Handlers::EnumType const& DataType::
    enum_ () const
    {
      return *enum__;
    }

    void DataType::
    enum_ (::DAnCE::Config_Handlers::EnumType const& e)
    {
      if (enum__)
      {
        *enum__ = e;
      }

      else
      {
        enum__ = std::make_unique<::DAnCE::Config_Handlers::EnumType> (e);
      }
    }

    // DataType
    bool DataType::
    struct_p () const
    {
      return !!struct__;
    }

    ::DAnCE::Config_Handlers::StructType const& DataType::
    struct_ () const
    {
      return *struct__;
    }

    void DataType::
    struct_ (::DAnCE::Config_Handlers::StructType const& e)
    {
      if (struct__)
      {
        *struct__ = e;
      }

      else
      {
        struct__ = std::make_unique<::DAnCE::Config_Handlers::StructType> (e);
      }
    }

    // DataType
    bool DataType::
    value_p () const
    {
      return !!value_;
    }

    ::DAnCE::Config_Handlers::ValueType const& DataType::
    value () const
    {
      return *value_;
    }

    void DataType::
    value (::DAnCE::Config_Handlers::ValueType const& e)
    {
      if (value_)
      {
        *value_ = e;
      }

      else
      {
        value_ = std::make_unique<::DAnCE::Config_Handlers::ValueType> (e);
      }
    }

    // DataType
    bool DataType::
    sequence_p () const
    {
      return !!sequence_;
    }

    ::DAnCE::Config_Handlers::SequenceType const& DataType::
    sequence () const
    {
      return *sequence_;
    }

    void DataType::
    sequence (::DAnCE::Config_Handlers::SequenceType const& e)
    {
      if (sequence_)
      {
        *sequence_ = e;
      }

      else
      {
        sequence_ = std::make_unique<::DAnCE::Config_Handlers::SequenceType> (e);
      }
    }

    // DataType
    bool DataType::
    alias_p () const
    {
      return !!alias_;
    }

    ::DAnCE::Config_Handlers::AliasType const& DataType::
    alias () const
    {
      return *alias_;
    }

    void DataType::
    alias (::DAnCE::Config_Handlers::AliasType const& e)
    {
      if (alias_)
      {
        *alias_ = e;
      }

      else
      {
        alias_ = std::make_unique<::DAnCE::Config_Handlers::AliasType> (e);
      }
    }

    // DataType
    bool DataType::
    array_p () const
    {
      return !!array_;
    }

    ::DAnCE::Config_Handlers::ArrayType const& DataType::
    array () const
    {
      return *array_;
    }

    void DataType::
    array (::DAnCE::Config_Handlers::ArrayType const& e)
    {
      if (array_)
      {
        *array_ = e;
      }

      else
      {
        array_ = std::make_unique<::DAnCE::Config_Handlers::ArrayType> (e);
      }
    }

    // DataType
    bool DataType::
    boundedString_p () const
    {
      return !!boundedString_;
    }

    ::DAnCE::Config_Handlers::BoundedStringType const& DataType::
    boundedString () const
    {
      return *boundedString_;
    }

    void DataType::
    boundedString (::DAnCE::Config_Handlers::BoundedStringType const& e)
    {
      if (boundedString_)
      {
        *boundedString_ = e;
      }

      else
      {
        boundedString_ = std::make_unique<::DAnCE::Config_Handlers::BoundedStringType> (e);
      }
    }

    // DataType
    bool DataType::
    id_p () const
    {
      return !!id_;
    }

    ::XMLSchema::ID<char> const& DataType::
    id () const
    {
      return *id_;
    }

    ::XMLSchema::ID<char>& DataType::
    id ()
    {
      return *id_;
    }

    void DataType::
    id (::XMLSchema::ID<char> const& e)
    {
      if (id_)
      {
        *id_ = e;
      }

      else
      {
        id_ = std::make_unique<::XMLSchema::ID<char>> (e);
      }
    }


    // DataValue

    DataValue::DataValue ()
    : ::XSCRT::Type ()
    {
    }

    DataValue::DataValue (DataValue const& s) :
    ::XSCRT::Type (s)
    , short__ (s.short__)
    , long__ (s.long__)
    , ushort_ (s.ushort_)
    , ulong_ (s.ulong_)
    , float__ (s.float__)
    , double__ (s.double__)
    , boolean_ (s.boolean_)
    , octet_ (s.octet_)
    , enum__ (s.enum__)
    , string_ (s.string_)
    , longlong_ (s.longlong_)
    , ulonglong_ (s.ulonglong_)
    , longdouble_ (s.longdouble_)
    , element_ (s.element_)
    , member_ (s.member_)
    {
    }

    DataValue&
    DataValue::operator= (DataValue const& s)
    {
      if (std::addressof(s) != this)
      {
        short__ = s.short__;

        long__ = s.long__;

        ushort_ = s.ushort_;

        ulong_ = s.ulong_;

        float__ = s.float__;

        double__ = s.double__;

        boolean_ = s.boolean_;

        octet_ = s.octet_;

        enum__ = s.enum__;

        string_ = s.string_;

        longlong_ = s.longlong_;

        ulonglong_ = s.ulonglong_;

        longdouble_ = s.longdouble_;

        element_ = s.element_;

        member_ = s.member_;
      }

      return *this;
    }


    // DataValue
    DataValue::short_const_iterator DataValue::
    begin_short () const
    {
      return short__.cbegin ();
    }

    DataValue::short_const_iterator DataValue::
    end_short () const
    {
      return short__.cend ();
    }

    size_t DataValue::
    count_short() const
    {
      return short__.size ();
    }

    // DataValue
    DataValue::long_const_iterator DataValue::
    begin_long () const
    {
      return long__.cbegin ();
    }

    DataValue::long_const_iterator DataValue::
    end_long () const
    {
      return long__.cend ();
    }

    size_t DataValue::
    count_long() const
    {
      return long__.size ();
    }

    // DataValue
    DataValue::ushort_const_iterator DataValue::
    begin_ushort () const
    {
      return ushort_.cbegin ();
    }

    DataValue::ushort_const_iterator DataValue::
    end_ushort () const
    {
      return ushort_.cend ();
    }

    size_t DataValue::
    count_ushort() const
    {
      return ushort_.size ();
    }

    // DataValue
    DataValue::ulong_const_iterator DataValue::
    begin_ulong () const
    {
      return ulong_.cbegin ();
    }

    DataValue::ulong_const_iterator DataValue::
    end_ulong () const
    {
      return ulong_.cend ();
    }

    size_t DataValue::
    count_ulong() const
    {
      return ulong_.size ();
    }

    // DataValue
    DataValue::float_const_iterator DataValue::
    begin_float () const
    {
      return float__.cbegin ();
    }

    DataValue::float_const_iterator DataValue::
    end_float () const
    {
      return float__.cend ();
    }

    size_t DataValue::
    count_float() const
    {
      return float__.size ();
    }

    // DataValue
    DataValue::double_const_iterator DataValue::
    begin_double () const
    {
      return double__.cbegin ();
    }

    DataValue::double_const_iterator DataValue::
    end_double () const
    {
      return double__.cend ();
    }

    size_t DataValue::
    count_double() const
    {
      return double__.size ();
    }

    // DataValue
    DataValue::boolean_const_iterator DataValue::
    begin_boolean () const
    {
      return boolean_.cbegin ();
    }

    DataValue::boolean_const_iterator DataValue::
    end_boolean () const
    {
      return boolean_.cend ();
    }

    size_t DataValue::
    count_boolean() const
    {
      return boolean_.size ();
    }

    // DataValue
    DataValue::octet_const_iterator DataValue::
    begin_octet () const
    {
      return octet_.cbegin ();
    }

    DataValue::octet_const_iterator DataValue::
    end_octet () const
    {
      return octet_.cend ();
    }

    size_t DataValue::
    count_octet() const
    {
      return octet_.size ();
    }

    // DataValue
    DataValue::enum_const_iterator DataValue::
    begin_enum () const
    {
      return enum__.cbegin ();
    }

    DataValue::enum_const_iterator DataValue::
    end_enum () const
    {
      return enum__.cend ();
    }

    size_t DataValue::
    count_enum() const
    {
      return enum__.size ();
    }

    // DataValue
    DataValue::string_const_iterator DataValue::
    begin_string () const
    {
      return string_.cbegin ();
    }

    DataValue::string_const_iterator DataValue::
    end_string () const
    {
      return string_.cend ();
    }

    size_t DataValue::
    count_string() const
    {
      return string_.size ();
    }

    // DataValue
    DataValue::longlong_const_iterator DataValue::
    begin_longlong () const
    {
      return longlong_.cbegin ();
    }

    DataValue::longlong_const_iterator DataValue::
    end_longlong () const
    {
      return longlong_.cend ();
    }

    size_t DataValue::
    count_longlong() const
    {
      return longlong_.size ();
    }

    // DataValue
    DataValue::ulonglong_const_iterator DataValue::
    begin_ulonglong () const
    {
      return ulonglong_.cbegin ();
    }

    DataValue::ulonglong_const_iterator DataValue::
    end_ulonglong () const
    {
      return ulonglong_.cend ();
    }

    size_t DataValue::
    count_ulonglong() const
    {
      return ulonglong_.size ();
    }

    // DataValue
    DataValue::longdouble_const_iterator DataValue::
    begin_longdouble () const
    {
      return longdouble_.cbegin ();
    }

    DataValue::longdouble_const_iterator DataValue::
    end_longdouble () const
    {
      return longdouble_.cend ();
    }

    size_t DataValue::
    count_longdouble() const
    {
      return longdouble_.size ();
    }

    // DataValue
    DataValue::element_const_iterator DataValue::
    begin_element () const
    {
      return element_.cbegin ();
    }

    DataValue::element_const_iterator DataValue::
    end_element () const
    {
      return element_.cend ();
    }

    size_t DataValue::
    count_element() const
    {
      return element_.size ();
    }

    // DataValue
    DataValue::member_const_iterator DataValue::
    begin_member () const
    {
      return member_.cbegin ();
    }

    DataValue::member_const_iterator DataValue::
    end_member () const
    {
      return member_.cend ();
    }

    size_t DataValue::
    count_member() const
    {
      return member_.size ();
    }


    // AliasType

    AliasType::AliasType (::XMLSchema::string<char> const& name__,
                          ::XMLSchema::string<char> const& typeId__,
                          ::DAnCE::Config_Handlers::DataType const& elementType__)
    : ::XSCRT::Type ()
    , name_ (std::make_unique<::XMLSchema::string<char>> (name__))
    , typeId_ (std::make_unique<::XMLSchema::string<char>> (typeId__))
    , elementType_ (std::make_unique<::DAnCE::Config_Handlers::DataType> (elementType__))
    {
    }

    AliasType::AliasType (AliasType const& s) :
    ::XSCRT::Type (s)
    , name_ (std::make_unique<::XMLSchema::string<char>> (*s.name_))
    , typeId_ (std::make_unique<::XMLSchema::string<char>> (*s.typeId_))
    , elementType_ (std::make_unique<::DAnCE::Config_Handlers::DataType> (*s.elementType_))
    {
    }

    AliasType&
    AliasType::operator= (AliasType const& s)
    {
      if (std::addressof(s) != this)
      {
        name (*s.name_);

        typeId (*s.typeId_);

        elementType (*s.elementType_);
      }

      return *this;
    }


    // AliasType
    ::XMLSchema::string<char> const& AliasType::
    name () const
    {
      return *name_;
    }

    void AliasType::
    name (::XMLSchema::string<char> const& e)
    {
      *name_ = e;
    }

    // AliasType
    ::XMLSchema::string<char> const& AliasType::
    typeId () const
    {
      return *typeId_;
    }

    void AliasType::
    typeId (::XMLSchema::string<char> const& e)
    {
      *typeId_ = e;
    }

    // AliasType
    ::DAnCE::Config_Handlers::DataType const& AliasType::
    elementType () const
    {
      return *elementType_;
    }

    void AliasType::
    elementType (::DAnCE::Config_Handlers::DataType const& e)
    {
      *elementType_ = e;
    }


    // EnumType

    EnumType::EnumType (::XMLSchema::string<char> const& name__,
                        ::XMLSchema::string<char> const& typeId__,
                        member_container_type const& member__)
    : ::XSCRT::Type ()
    , name_ (std::make_unique<::XMLSchema::string<char>> (name__))
    , typeId_ (std::make_unique<::XMLSchema::string<char>> (typeId__))
    , member_ (member__)
    {
    }

    EnumType::EnumType (EnumType const& s) :
    ::XSCRT::Type (s)
    , name_ (std::make_unique<::XMLSchema::string<char>> (*s.name_))
    , typeId_ (std::make_unique<::XMLSchema::string<char>> (*s.typeId_))
    , member_ (s.member_)
    {
    }

    EnumType&
    EnumType::operator= (EnumType const& s)
    {
      if (std::addressof(s) != this)
      {
        name (*s.name_);

        typeId (*s.typeId_);

        member_ = s.member_;
      }

      return *this;
    }


    // EnumType
    ::XMLSchema::string<char> const& EnumType::
    name () const
    {
      return *name_;
    }

    void EnumType::
    name (::XMLSchema::string<char> const& e)
    {
      *name_ = e;
    }

    // EnumType
    ::XMLSchema::string<char> const& EnumType::
    typeId () const
    {
      return *typeId_;
    }

    void EnumType::
    typeId (::XMLSchema::string<char> const& e)
    {
      *typeId_ = e;
    }

    // EnumType
    EnumType::member_const_iterator EnumType::
    begin_member () const
    {
      return member_.cbegin ();
    }

    EnumType::member_const_iterator EnumType::
    end_member () const
    {
      return member_.cend ();
    }

    size_t EnumType::
    count_member() const
    {
      return member_.size ();
    }


    // BoundedStringType

    BoundedStringType::BoundedStringType ()
    : ::XSCRT::Type ()
    {
    }

    BoundedStringType::BoundedStringType (BoundedStringType const& s) :
    ::XSCRT::Type (s)
    , bound_ (s.bound_)
    {
    }

    BoundedStringType&
    BoundedStringType::operator= (BoundedStringType const& s)
    {
      if (std::addressof(s) != this)
      {
        bound_ = s.bound_;
      }

      return *this;
    }


    // BoundedStringType
    BoundedStringType::bound_const_iterator BoundedStringType::
    begin_bound () const
    {
      return bound_.cbegin ();
    }

    BoundedStringType::bound_const_iterator BoundedStringType::
    end_bound () const
    {
      return bound_.cend ();
    }

    size_t BoundedStringType::
    count_bound() const
    {
      return bound_.size ();
    }


    // StructType

    StructType::StructType (::XMLSchema::string<char> const& name__,
                            ::XMLSchema::string<char> const& typeId__)
    : ::XSCRT::Type ()
    , name_ (std::make_unique<::XMLSchema::string<char>> (name__))
    , typeId_ (std::make_unique<::XMLSchema::string<char>> (typeId__))
    {
    }

    StructType::StructType (StructType const& s) :
    ::XSCRT::Type (s)
    , name_ (std::make_unique<::XMLSchema::string<char>> (*s.name_))
    , typeId_ (std::make_unique<::XMLSchema::string<char>> (*s.typeId_))
    , member_ (s.member_)
    {
    }

    StructType&
    StructType::operator= (StructType const& s)
    {
      if (std::addressof(s) != this)
      {
        name (*s.name_);

        typeId (*s.typeId_);

        member_ = s.member_;
      }

      return *this;
    }


    // StructType
    ::XMLSchema::string<char> const& StructType::
    name () const
    {
      return *name_;
    }

    void StructType::
    name (::XMLSchema::string<char> const& e)
    {
      *name_ = e;
    }

    // StructType
    ::XMLSchema::string<char> const& StructType::
    typeId () const
    {
      return *typeId_;
    }

    void StructType::
    typeId (::XMLSchema::string<char> const& e)
    {
      *typeId_ = e;
    }

    // StructType
    StructType::member_const_iterator StructType::
    begin_member () const
    {
      return member_.cbegin ();
    }

    StructType::member_const_iterator StructType::
    end_member () const
    {
      return member_.cend ();
    }

    size_t StructType::
    count_member() const
    {
      return member_.size ();
    }


    // StructMemberType

    StructMemberType::StructMemberType (::XMLSchema::string<char> const& name__,
                                        ::DAnCE::Config_Handlers::DataType const& type__)
    : ::XSCRT::Type ()
    , name_ (std::make_unique<::XMLSchema::string<char>> (name__))
    , type_ (std::make_unique<::DAnCE::Config_Handlers::DataType> (type__))
    {
    }

    StructMemberType::StructMemberType (StructMemberType const& s) :
    ::XSCRT::Type (s)
    , name_ (std::make_unique<::XMLSchema::string<char>> (*s.name_))
    , type_ (std::make_unique<::DAnCE::Config_Handlers::DataType> (*s.type_))
    {
    }

    StructMemberType&
    StructMemberType::operator= (StructMemberType const& s)
    {
      if (std::addressof(s) != this)
      {
        name (*s.name_);

        type (*s.type_);
      }

      return *this;
    }


    // StructMemberType
    ::XMLSchema::string<char> const& StructMemberType::
    name () const
    {
      return *name_;
    }

    void StructMemberType::
    name (::XMLSchema::string<char> const& e)
    {
      *name_ = e;
    }

    // StructMemberType
    ::DAnCE::Config_Handlers::DataType const& StructMemberType::
    type () const
    {
      return *type_;
    }

    void StructMemberType::
    type (::DAnCE::Config_Handlers::DataType const& e)
    {
      *type_ = e;
    }


    // ValueType

    ValueType::ValueType (::XMLSchema::string<char> const& name__,
                          ::XMLSchema::string<char> const& typeId__,
                          ::XMLSchema::string<char> const& modifier__,
                          ::DAnCE::Config_Handlers::DataType const& baseType__)
    : ::XSCRT::Type ()
    , name_ (std::make_unique<::XMLSchema::string<char>> (name__))
    , typeId_ (std::make_unique<::XMLSchema::string<char>> (typeId__))
    , modifier_ (std::make_unique<::XMLSchema::string<char>> (modifier__))
    , baseType_ (std::make_unique<::DAnCE::Config_Handlers::DataType> (baseType__))
    {
    }

    ValueType::ValueType (ValueType const& s) :
    ::XSCRT::Type (s)
    , name_ (std::make_unique<::XMLSchema::string<char>> (*s.name_))
    , typeId_ (std::make_unique<::XMLSchema::string<char>> (*s.typeId_))
    , modifier_ (std::make_unique<::XMLSchema::string<char>> (*s.modifier_))
    , baseType_ (std::make_unique<::DAnCE::Config_Handlers::DataType> (*s.baseType_))
    , member_ (s.member_)
    {
    }

    ValueType&
    ValueType::operator= (ValueType const& s)
    {
      if (std::addressof(s) != this)
      {
        name (*s.name_);

        typeId (*s.typeId_);

        modifier (*s.modifier_);

        baseType (*s.baseType_);

        member_ = s.member_;
      }

      return *this;
    }


    // ValueType
    ::XMLSchema::string<char> const& ValueType::
    name () const
    {
      return *name_;
    }

    void ValueType::
    name (::XMLSchema::string<char> const& e)
    {
      *name_ = e;
    }

    // ValueType
    ::XMLSchema::string<char> const& ValueType::
    typeId () const
    {
      return *typeId_;
    }

    void ValueType::
    typeId (::XMLSchema::string<char> const& e)
    {
      *typeId_ = e;
    }

    // ValueType
    ::XMLSchema::string<char> const& ValueType::
    modifier () const
    {
      return *modifier_;
    }

    void ValueType::
    modifier (::XMLSchema::string<char> const& e)
    {
      *modifier_ = e;
    }

    // ValueType
    ::DAnCE::Config_Handlers::DataType const& ValueType::
    baseType () const
    {
      return *baseType_;
    }

    void ValueType::
    baseType (::DAnCE::Config_Handlers::DataType const& e)
    {
      *baseType_ = e;
    }

    // ValueType
    ValueType::member_const_iterator ValueType::
    begin_member () const
    {
      return member_.cbegin ();
    }

    ValueType::member_const_iterator ValueType::
    end_member () const
    {
      return member_.cend ();
    }

    size_t ValueType::
    count_member() const
    {
      return member_.size ();
    }


    // ValueMemberType

    ValueMemberType::ValueMemberType (::XMLSchema::string<char> const& name__,
                                      ::XMLSchema::string<char> const& visibility__,
                                      ::DAnCE::Config_Handlers::DataType const& type__)
    : ::XSCRT::Type ()
    , name_ (std::make_unique<::XMLSchema::string<char>> (name__))
    , visibility_ (std::make_unique<::XMLSchema::string<char>> (visibility__))
    , type_ (std::make_unique<::DAnCE::Config_Handlers::DataType> (type__))
    {
    }

    ValueMemberType::ValueMemberType (ValueMemberType const& s) :
    ::XSCRT::Type (s)
    , name_ (std::make_unique<::XMLSchema::string<char>> (*s.name_))
    , visibility_ (std::make_unique<::XMLSchema::string<char>> (*s.visibility_))
    , type_ (std::make_unique<::DAnCE::Config_Handlers::DataType> (*s.type_))
    {
    }

    ValueMemberType&
    ValueMemberType::operator= (ValueMemberType const& s)
    {
      if (std::addressof(s) != this)
      {
        name (*s.name_);

        visibility (*s.visibility_);

        type (*s.type_);
      }

      return *this;
    }


    // ValueMemberType
    ::XMLSchema::string<char> const& ValueMemberType::
    name () const
    {
      return *name_;
    }

    void ValueMemberType::
    name (::XMLSchema::string<char> const& e)
    {
      *name_ = e;
    }

    // ValueMemberType
    ::XMLSchema::string<char> const& ValueMemberType::
    visibility () const
    {
      return *visibility_;
    }

    void ValueMemberType::
    visibility (::XMLSchema::string<char> const& e)
    {
      *visibility_ = e;
    }

    // ValueMemberType
    ::DAnCE::Config_Handlers::DataType const& ValueMemberType::
    type () const
    {
      return *type_;
    }

    void ValueMemberType::
    type (::DAnCE::Config_Handlers::DataType const& e)
    {
      *type_ = e;
    }


    // NamedValue

    NamedValue::NamedValue (::XMLSchema::string<char> const& name__,
                            ::DAnCE::Config_Handlers::DataValue const& value__)
    : ::XSCRT::Type ()
    , name_ (std::make_unique<::XMLSchema::string<char>> (name__))
    , value_ (std::make_unique<::DAnCE::Config_Handlers::DataValue> (value__))
    {
    }

    NamedValue::NamedValue (NamedValue const& s) :
    ::XSCRT::Type (s)
    , name_ (std::make_unique<::XMLSchema::string<char>> (*s.name_))
    , value_ (std::make_unique<::DAnCE::Config_Handlers::DataValue> (*s.value_))
    {
    }

    NamedValue&
    NamedValue::operator= (NamedValue const& s)
    {
      if (std::addressof(s) != this)
      {
        name (*s.name_);

        value (*s.value_);
      }

      return *this;
    }


    // NamedValue
    ::XMLSchema::string<char> const& NamedValue::
    name () const
    {
      return *name_;
    }

    void NamedValue::
    name (::XMLSchema::string<char> const& e)
    {
      *name_ = e;
    }

    // NamedValue
    ::DAnCE::Config_Handlers::DataValue const& NamedValue::
    value () const
    {
      return *value_;
    }

    void NamedValue::
    value (::DAnCE::Config_Handlers::DataValue const& e)
    {
      *value_ = e;
    }


    // ArrayType

    ArrayType::ArrayType (::XMLSchema::unsignedInt const& length__,
                          ::DAnCE::Config_Handlers::DataType const& elementType__)
    : ::XSCRT::Type ()
    , length_ (std::make_unique<::XMLSchema::unsignedInt> (length__))
    , elementType_ (std::make_unique<::DAnCE::Config_Handlers::DataType> (elementType__))
    {
    }

    ArrayType::ArrayType (ArrayType const& s) :
    ::XSCRT::Type (s)
    , length_ (std::make_unique<::XMLSchema::unsignedInt> (*s.length_))
    , elementType_ (std::make_unique<::DAnCE::Config_Handlers::DataType> (*s.elementType_))
    {
    }

    ArrayType&
    ArrayType::operator= (ArrayType const& s)
    {
      if (std::addressof(s) != this)
      {
        length (*s.length_);

        elementType (*s.elementType_);
      }

      return *this;
    }


    // ArrayType
    ::XMLSchema::unsignedInt const& ArrayType::
    length () const
    {
      return *length_;
    }

    void ArrayType::
    length (::XMLSchema::unsignedInt const& e)
    {
      *length_ = e;
    }

    // ArrayType
    ::DAnCE::Config_Handlers::DataType const& ArrayType::
    elementType () const
    {
      return *elementType_;
    }

    void ArrayType::
    elementType (::DAnCE::Config_Handlers::DataType const& e)
    {
      *elementType_ = e;
    }


    // SequenceType

    SequenceType::SequenceType (::DAnCE::Config_Handlers::DataType const& elementType__)
    : ::XSCRT::Type ()
    , elementType_ (std::make_unique<::DAnCE::Config_Handlers::DataType> (elementType__))
    {
    }

    SequenceType::SequenceType (SequenceType const& s) :
    ::XSCRT::Type (s)
    , bound_ (s.bound_ ? std::make_unique<::XMLSchema::unsignedInt> (*s.bound_) : nullptr)
    , elementType_ (std::make_unique<::DAnCE::Config_Handlers::DataType> (*s.elementType_))
    {
    }

    SequenceType&
    SequenceType::operator= (SequenceType const& s)
    {
      if (std::addressof(s) != this)
      {
        if (s.bound_)
          bound (*(s.bound_));
        else
          bound_.release ();

        elementType (*s.elementType_);
      }

      return *this;
    }


    // SequenceType
    bool SequenceType::
    bound_p () const
    {
      return !!bound_;
    }

    ::XMLSchema::unsignedInt const& SequenceType::
    bound () const
    {
      return *bound_;
    }

    void SequenceType::
    bound (::XMLSchema::unsignedInt const& e)
    {
      if (bound_)
      {
        *bound_ = e;
      }

      else
      {
        bound_ = std::make_unique<::XMLSchema::unsignedInt> (e);
      }
    }

    // SequenceType
    ::DAnCE::Config_Handlers::DataType const& SequenceType::
    elementType () const
    {
      return *elementType_;
    }

    void SequenceType::
    elementType (::DAnCE::Config_Handlers::DataType const& e)
    {
      *elementType_ = e;
    }


    // Any

    Any::Any (::DAnCE::Config_Handlers::DataType const& type__,
              ::DAnCE::Config_Handlers::DataValue const& value__)
    : ::XSCRT::Type ()
    , type_ (std::make_unique<::DAnCE::Config_Handlers::DataType> (type__))
    , value_ (std::make_unique<::DAnCE::Config_Handlers::DataValue> (value__))
    {
    }

    Any::Any (Any const& s) :
    ::XSCRT::Type (s)
    , type_ (std::make_unique<::DAnCE::Config_Handlers::DataType> (*s.type_))
    , value_ (std::make_unique<::DAnCE::Config_Handlers::DataValue> (*s.value_))
    {
    }

    Any&
    Any::operator= (Any const& s)
    {
      if (std::addressof(s) != this)
      {
        type (*s.type_);

        value (*s.value_);
      }

      return *this;
    }


    // Any
    ::DAnCE::Config_Handlers::DataType const& Any::
    type () const
    {
      return *type_;
    }

    void Any::
    type (::DAnCE::Config_Handlers::DataType const& e)
    {
      *type_ = e;
    }

    // Any
    ::DAnCE::Config_Handlers::DataValue const& Any::
    value () const
    {
      return *value_;
    }

    void Any::
    value (::DAnCE::Config_Handlers::DataValue const& e)
    {
      *value_ = e;
    }


    // Property

    Property::Property (::XMLSchema::string<char> const& name__,
                        ::DAnCE::Config_Handlers::Any const& value__)
    : ::XSCRT::Type ()
    , name_ (std::make_unique<::XMLSchema::string<char>> (name__))
    , value_ (std::make_unique<::DAnCE::Config_Handlers::Any> (value__))
    {
    }

    Property::Property (Property const& s) :
    ::XSCRT::Type (s)
    , name_ (std::make_unique<::XMLSchema::string<char>> (*s.name_))
    , value_ (std::make_unique<::DAnCE::Config_Handlers::Any> (*s.value_))
    {
    }

    Property&
    Property::operator= (Property const& s)
    {
      if (std::addressof(s) != this)
      {
        name (*s.name_);

        value (*s.value_);
      }

      return *this;
    }


    // Property
    ::XMLSchema::string<char> const& Property::
    name () const
    {
      return *name_;
    }

    void Property::
    name (::XMLSchema::string<char> const& e)
    {
      *name_ = e;
    }

    // Property
    ::DAnCE::Config_Handlers::Any const& Property::
    value () const
    {
      return *value_;
    }

    void Property::
    value (::DAnCE::Config_Handlers::Any const& e)
    {
      *value_ = e;
    }


    // SatisfierPropertyKind

    SatisfierPropertyKind::Value SatisfierPropertyKind::
    integral () const
    {
      return v_;
    }

    bool
    operator== (::DAnCE::Config_Handlers::SatisfierPropertyKind const& a, ::DAnCE::Config_Handlers::SatisfierPropertyKind const& b)
    {
      return a.v_ == b.v_;
    }

    bool
    operator!= (::DAnCE::Config_Handlers::SatisfierPropertyKind const& a, ::DAnCE::Config_Handlers::SatisfierPropertyKind const& b)
    {
      return a.v_ != b.v_;
    }

    SatisfierPropertyKind::
    SatisfierPropertyKind (SatisfierPropertyKind::Value v)
    : v_ (v)
    {
    }

    // SatisfierProperty

    SatisfierProperty::SatisfierProperty (::XMLSchema::string<char> const& name__,
                                          ::DAnCE::Config_Handlers::SatisfierPropertyKind const& kind__,
                                          ::XMLSchema::boolean const& dynamic__,
                                          ::DAnCE::Config_Handlers::Any const& value__)
    : ::XSCRT::Type ()
    , name_ (std::make_unique<::XMLSchema::string<char>> (name__))
    , kind_ (std::make_unique<::DAnCE::Config_Handlers::SatisfierPropertyKind> (kind__))
    , dynamic_ (std::make_unique<::XMLSchema::boolean> (dynamic__))
    , value_ (std::make_unique<::DAnCE::Config_Handlers::Any> (value__))
    {
    }

    SatisfierProperty::SatisfierProperty (SatisfierProperty const& s) :
    ::XSCRT::Type (s)
    , name_ (std::make_unique<::XMLSchema::string<char>> (*s.name_))
    , kind_ (std::make_unique<::DAnCE::Config_Handlers::SatisfierPropertyKind> (*s.kind_))
    , dynamic_ (std::make_unique<::XMLSchema::boolean> (*s.dynamic_))
    , value_ (std::make_unique<::DAnCE::Config_Handlers::Any> (*s.value_))
    {
    }

    SatisfierProperty&
    SatisfierProperty::operator= (SatisfierProperty const& s)
    {
      if (std::addressof(s) != this)
      {
        name (*s.name_);

        kind (*s.kind_);

        dynamic (*s.dynamic_);

        value (*s.value_);
      }

      return *this;
    }


    // SatisfierProperty
    ::XMLSchema::string<char> const& SatisfierProperty::
    name () const
    {
      return *name_;
    }

    void SatisfierProperty::
    name (::XMLSchema::string<char> const& e)
    {
      *name_ = e;
    }

    // SatisfierProperty
    ::DAnCE::Config_Handlers::SatisfierPropertyKind const& SatisfierProperty::
    kind () const
    {
      return *kind_;
    }

    void SatisfierProperty::
    kind (::DAnCE::Config_Handlers::SatisfierPropertyKind const& e)
    {
      *kind_ = e;
    }

    // SatisfierProperty
    ::XMLSchema::boolean const& SatisfierProperty::
    dynamic () const
    {
      return *dynamic_;
    }

    void SatisfierProperty::
    dynamic (::XMLSchema::boolean const& e)
    {
      *dynamic_ = e;
    }

    // SatisfierProperty
    ::DAnCE::Config_Handlers::Any const& SatisfierProperty::
    value () const
    {
      return *value_;
    }

    void SatisfierProperty::
    value (::DAnCE::Config_Handlers::Any const& e)
    {
      *value_ = e;
    }


    // Resource

    Resource::Resource (::XMLSchema::string<char> const& name__,
                        resourceType_container_type const& resourceType__)
    : ::XSCRT::Type ()
    , name_ (std::make_unique<::XMLSchema::string<char>> (name__))
    , resourceType_ (resourceType__)
    {
    }

    Resource::Resource (Resource const& s) :
    ::XSCRT::Type (s)
    , name_ (std::make_unique<::XMLSchema::string<char>> (*s.name_))
    , resourceType_ (s.resourceType_)
    , property_ (s.property_)
    {
    }

    Resource&
    Resource::operator= (Resource const& s)
    {
      if (std::addressof(s) != this)
      {
        name (*s.name_);

        resourceType_ = s.resourceType_;

        property_ = s.property_;
      }

      return *this;
    }


    // Resource
    ::XMLSchema::string<char> const& Resource::
    name () const
    {
      return *name_;
    }

    void Resource::
    name (::XMLSchema::string<char> const& e)
    {
      *name_ = e;
    }

    // Resource
    Resource::resourceType_const_iterator Resource::
    begin_resourceType () const
    {
      return resourceType_.cbegin ();
    }

    Resource::resourceType_const_iterator Resource::
    end_resourceType () const
    {
      return resourceType_.cend ();
    }

    size_t Resource::
    count_resourceType() const
    {
      return resourceType_.size ();
    }

    // Resource
    Resource::property_const_iterator Resource::
    begin_property () const
    {
      return property_.cbegin ();
    }

    Resource::property_const_iterator Resource::
    end_property () const
    {
      return property_.cend ();
    }

    size_t Resource::
    count_property() const
    {
      return property_.size ();
    }


    // Requirement

    Requirement::Requirement (::XMLSchema::string<char> const& name__,
                              ::XMLSchema::string<char> const& resourceType__)
    : ::XSCRT::Type ()
    , name_ (std::make_unique<::XMLSchema::string<char>> (name__))
    , resourceType_ (std::make_unique<::XMLSchema::string<char>> (resourceType__))
    {
    }

    Requirement::Requirement (Requirement const& s) :
    ::XSCRT::Type (s)
    , name_ (std::make_unique<::XMLSchema::string<char>> (*s.name_))
    , resourceType_ (std::make_unique<::XMLSchema::string<char>> (*s.resourceType_))
    , property_ (s.property_)
    {
    }

    Requirement&
    Requirement::operator= (Requirement const& s)
    {
      if (std::addressof(s) != this)
      {
        name (*s.name_);

        resourceType (*s.resourceType_);

        property_ = s.property_;
      }

      return *this;
    }


    // Requirement
    ::XMLSchema::string<char> const& Requirement::
    name () const
    {
      return *name_;
    }

    void Requirement::
    name (::XMLSchema::string<char> const& e)
    {
      *name_ = e;
    }

    // Requirement
    ::XMLSchema::string<char> const& Requirement::
    resourceType () const
    {
      return *resourceType_;
    }

    void Requirement::
    resourceType (::XMLSchema::string<char> const& e)
    {
      *resourceType_ = e;
    }

    // Requirement
    Requirement::property_const_iterator Requirement::
    begin_property () const
    {
      return property_.cbegin ();
    }

    Requirement::property_const_iterator Requirement::
    end_property () const
    {
      return property_.cend ();
    }

    size_t Requirement::
    count_property() const
    {
      return property_.size ();
    }


    // ResourceDeploymentDescription

    ResourceDeploymentDescription::ResourceDeploymentDescription (::XMLSchema::string<char> const& requirementName__,
                                                                  ::XMLSchema::string<char> const& resourceName__)
    : ::XSCRT::Type ()
    , requirementName_ (std::make_unique<::XMLSchema::string<char>> (requirementName__))
    , resourceName_ (std::make_unique<::XMLSchema::string<char>> (resourceName__))
    {
    }

    ResourceDeploymentDescription::ResourceDeploymentDescription (ResourceDeploymentDescription const& s) :
    ::XSCRT::Type (s)
    , requirementName_ (std::make_unique<::XMLSchema::string<char>> (*s.requirementName_))
    , resourceName_ (std::make_unique<::XMLSchema::string<char>> (*s.resourceName_))
    , property_ (s.property_)
    {
    }

    ResourceDeploymentDescription&
    ResourceDeploymentDescription::operator= (ResourceDeploymentDescription const& s)
    {
      if (std::addressof(s) != this)
      {
        requirementName (*s.requirementName_);

        resourceName (*s.resourceName_);

        property_ = s.property_;
      }

      return *this;
    }


    // ResourceDeploymentDescription
    ::XMLSchema::string<char> const& ResourceDeploymentDescription::
    requirementName () const
    {
      return *requirementName_;
    }

    void ResourceDeploymentDescription::
    requirementName (::XMLSchema::string<char> const& e)
    {
      *requirementName_ = e;
    }

    // ResourceDeploymentDescription
    ::XMLSchema::string<char> const& ResourceDeploymentDescription::
    resourceName () const
    {
      return *resourceName_;
    }

    void ResourceDeploymentDescription::
    resourceName (::XMLSchema::string<char> const& e)
    {
      *resourceName_ = e;
    }

    // ResourceDeploymentDescription
    ResourceDeploymentDescription::property_const_iterator ResourceDeploymentDescription::
    begin_property () const
    {
      return property_.cbegin ();
    }

    ResourceDeploymentDescription::property_const_iterator ResourceDeploymentDescription::
    end_property () const
    {
      return property_.cend ();
    }

    size_t ResourceDeploymentDescription::
    count_property() const
    {
      return property_.size ();
    }


    // ArtifactDeploymentDescription

    ArtifactDeploymentDescription::ArtifactDeploymentDescription (::XMLSchema::string<char> const& name__,
                                                                  ::XMLSchema::string<char> const& node__)
    : ::XSCRT::Type ()
    , name_ (std::make_unique<::XMLSchema::string<char>> (name__))
    , node_ (std::make_unique<::XMLSchema::string<char>> (node__))
    {
    }

    ArtifactDeploymentDescription::ArtifactDeploymentDescription (ArtifactDeploymentDescription const& s) :
    ::XSCRT::Type (s)
    , name_ (std::make_unique<::XMLSchema::string<char>> (*s.name_))
    , source_ (s.source_)
    , node_ (std::make_unique<::XMLSchema::string<char>> (*s.node_))
    , location_ (s.location_)
    , execParameter_ (s.execParameter_)
    , deployRequirement_ (s.deployRequirement_)
    , deployedResource_ (s.deployedResource_)
    , id_ (s.id_ ? std::make_unique<::XMLSchema::ID<char>> (*s.id_) : nullptr)
    {
    }

    ArtifactDeploymentDescription&
    ArtifactDeploymentDescription::operator= (ArtifactDeploymentDescription const& s)
    {
      if (std::addressof(s) != this)
      {
        name (*s.name_);

        source_ = s.source_;

        node (*s.node_);

        location_ = s.location_;

        execParameter_ = s.execParameter_;

        deployRequirement_ = s.deployRequirement_;

        deployedResource_ = s.deployedResource_;

        if (s.id_) id (*(s.id_));
        else id_.release ();
      }

      return *this;
    }


    // ArtifactDeploymentDescription
    ::XMLSchema::string<char> const& ArtifactDeploymentDescription::
    name () const
    {
      return *name_;
    }

    void ArtifactDeploymentDescription::
    name (::XMLSchema::string<char> const& e)
    {
      *name_ = e;
    }

    // ArtifactDeploymentDescription
    ArtifactDeploymentDescription::source_const_iterator ArtifactDeploymentDescription::
    begin_source () const
    {
      return source_.cbegin ();
    }

    ArtifactDeploymentDescription::source_const_iterator ArtifactDeploymentDescription::
    end_source () const
    {
      return source_.cend ();
    }

    size_t ArtifactDeploymentDescription::
    count_source() const
    {
      return source_.size ();
    }

    // ArtifactDeploymentDescription
    ::XMLSchema::string<char> const& ArtifactDeploymentDescription::
    node () const
    {
      return *node_;
    }

    void ArtifactDeploymentDescription::
    node (::XMLSchema::string<char> const& e)
    {
      *node_ = e;
    }

    // ArtifactDeploymentDescription
    ArtifactDeploymentDescription::location_const_iterator ArtifactDeploymentDescription::
    begin_location () const
    {
      return location_.cbegin ();
    }

    ArtifactDeploymentDescription::location_const_iterator ArtifactDeploymentDescription::
    end_location () const
    {
      return location_.cend ();
    }

    size_t ArtifactDeploymentDescription::
    count_location() const
    {
      return location_.size ();
    }

    // ArtifactDeploymentDescription
    ArtifactDeploymentDescription::execParameter_const_iterator ArtifactDeploymentDescription::
    begin_execParameter () const
    {
      return execParameter_.cbegin ();
    }

    ArtifactDeploymentDescription::execParameter_const_iterator ArtifactDeploymentDescription::
    end_execParameter () const
    {
      return execParameter_.cend ();
    }

    size_t ArtifactDeploymentDescription::
    count_execParameter() const
    {
      return execParameter_.size ();
    }

    // ArtifactDeploymentDescription
    ArtifactDeploymentDescription::deployRequirement_const_iterator ArtifactDeploymentDescription::
    begin_deployRequirement () const
    {
      return deployRequirement_.cbegin ();
    }

    ArtifactDeploymentDescription::deployRequirement_const_iterator ArtifactDeploymentDescription::
    end_deployRequirement () const
    {
      return deployRequirement_.cend ();
    }

    size_t ArtifactDeploymentDescription::
    count_deployRequirement() const
    {
      return deployRequirement_.size ();
    }

    // ArtifactDeploymentDescription
    ArtifactDeploymentDescription::deployedResource_const_iterator ArtifactDeploymentDescription::
    begin_deployedResource () const
    {
      return deployedResource_.cbegin ();
    }

    ArtifactDeploymentDescription::deployedResource_const_iterator ArtifactDeploymentDescription::
    end_deployedResource () const
    {
      return deployedResource_.cend ();
    }

    size_t ArtifactDeploymentDescription::
    count_deployedResource() const
    {
      return deployedResource_.size ();
    }

    // ArtifactDeploymentDescription
    bool ArtifactDeploymentDescription::
    id_p () const
    {
      return !!id_;
    }

    ::XMLSchema::ID<char> const& ArtifactDeploymentDescription::
    id () const
    {
      return *id_;
    }

    ::XMLSchema::ID<char>& ArtifactDeploymentDescription::
    id ()
    {
      return *id_;
    }

    void ArtifactDeploymentDescription::
    id (::XMLSchema::ID<char> const& e)
    {
      if (id_)
      {
        *id_ = e;
      }

      else
      {
        id_ = std::make_unique<::XMLSchema::ID<char>> (e);
      }
    }


    // MonolithicDeploymentDescription

    MonolithicDeploymentDescription::MonolithicDeploymentDescription (::XMLSchema::string<char> const& name__)
    : ::XSCRT::Type ()
    , name_ (std::make_unique<::XMLSchema::string<char>> (name__))
    {
    }

    MonolithicDeploymentDescription::MonolithicDeploymentDescription (MonolithicDeploymentDescription const& s) :
    ::XSCRT::Type (s)
    , name_ (std::make_unique<::XMLSchema::string<char>> (*s.name_))
    , source_ (s.source_)
    , artifact_ (s.artifact_)
    , execParameter_ (s.execParameter_)
    , deployRequirement_ (s.deployRequirement_)
    , id_ (s.id_ ? std::make_unique<::XMLSchema::ID<char>> (*s.id_) : nullptr)
    {
    }

    MonolithicDeploymentDescription&
    MonolithicDeploymentDescription::operator= (MonolithicDeploymentDescription const& s)
    {
      if (std::addressof(s) != this)
      {
        name (*s.name_);

        source_ = s.source_;

        artifact_ = s.artifact_;

        execParameter_ = s.execParameter_;

        deployRequirement_ = s.deployRequirement_;

        if (s.id_) id (*(s.id_));
        else id_.release ();
      }

      return *this;
    }


    // MonolithicDeploymentDescription
    ::XMLSchema::string<char> const& MonolithicDeploymentDescription::
    name () const
    {
      return *name_;
    }

    void MonolithicDeploymentDescription::
    name (::XMLSchema::string<char> const& e)
    {
      *name_ = e;
    }

    // MonolithicDeploymentDescription
    MonolithicDeploymentDescription::source_const_iterator MonolithicDeploymentDescription::
    begin_source () const
    {
      return source_.cbegin ();
    }

    MonolithicDeploymentDescription::source_const_iterator MonolithicDeploymentDescription::
    end_source () const
    {
      return source_.cend ();
    }

    size_t MonolithicDeploymentDescription::
    count_source() const
    {
      return source_.size ();
    }

    // MonolithicDeploymentDescription
    MonolithicDeploymentDescription::artifact_const_iterator MonolithicDeploymentDescription::
    begin_artifact () const
    {
      return artifact_.cbegin ();
    }

    MonolithicDeploymentDescription::artifact_const_iterator MonolithicDeploymentDescription::
    end_artifact () const
    {
      return artifact_.cend ();
    }

    size_t MonolithicDeploymentDescription::
    count_artifact() const
    {
      return artifact_.size ();
    }

    // MonolithicDeploymentDescription
    MonolithicDeploymentDescription::execParameter_const_iterator MonolithicDeploymentDescription::
    begin_execParameter () const
    {
      return execParameter_.cbegin ();
    }

    MonolithicDeploymentDescription::execParameter_const_iterator MonolithicDeploymentDescription::
    end_execParameter () const
    {
      return execParameter_.cend ();
    }

    size_t MonolithicDeploymentDescription::
    count_execParameter() const
    {
      return execParameter_.size ();
    }

    // MonolithicDeploymentDescription
    MonolithicDeploymentDescription::deployRequirement_const_iterator MonolithicDeploymentDescription::
    begin_deployRequirement () const
    {
      return deployRequirement_.cbegin ();
    }

    MonolithicDeploymentDescription::deployRequirement_const_iterator MonolithicDeploymentDescription::
    end_deployRequirement () const
    {
      return deployRequirement_.cend ();
    }

    size_t MonolithicDeploymentDescription::
    count_deployRequirement() const
    {
      return deployRequirement_.size ();
    }

    // MonolithicDeploymentDescription
    bool MonolithicDeploymentDescription::
    id_p () const
    {
      return !!id_;
    }

    ::XMLSchema::ID<char> const& MonolithicDeploymentDescription::
    id () const
    {
      return *id_;
    }

    ::XMLSchema::ID<char>& MonolithicDeploymentDescription::
    id ()
    {
      return *id_;
    }

    void MonolithicDeploymentDescription::
    id (::XMLSchema::ID<char> const& e)
    {
      if (id_)
      {
        *id_ = e;
      }

      else
      {
        id_ = std::make_unique<::XMLSchema::ID<char>> (e);
      }
    }


    // ResourceUsageKind

    ResourceUsageKind::Value ResourceUsageKind::
    integral () const
    {
      return v_;
    }

    bool
    operator== (::DAnCE::Config_Handlers::ResourceUsageKind const& a, ::DAnCE::Config_Handlers::ResourceUsageKind const& b)
    {
      return a.v_ == b.v_;
    }

    bool
    operator!= (::DAnCE::Config_Handlers::ResourceUsageKind const& a, ::DAnCE::Config_Handlers::ResourceUsageKind const& b)
    {
      return a.v_ != b.v_;
    }

    ResourceUsageKind::
    ResourceUsageKind (ResourceUsageKind::Value v)
    : v_ (v)
    {
    }

    // InstanceResourceDeploymentDescription

    InstanceResourceDeploymentDescription::InstanceResourceDeploymentDescription (::DAnCE::Config_Handlers::ResourceUsageKind const& resourceUsage__,
                                                                                  ::XMLSchema::string<char> const& requirementName__,
                                                                                  ::XMLSchema::string<char> const& resourceName__)
    : ::XSCRT::Type ()
    , resourceUsage_ (std::make_unique<::DAnCE::Config_Handlers::ResourceUsageKind> (resourceUsage__))
    , requirementName_ (std::make_unique<::XMLSchema::string<char>> (requirementName__))
    , resourceName_ (std::make_unique<::XMLSchema::string<char>> (resourceName__))
    {
    }

    InstanceResourceDeploymentDescription::InstanceResourceDeploymentDescription (InstanceResourceDeploymentDescription const& s) :
    ::XSCRT::Type (s)
    , resourceUsage_ (std::make_unique<::DAnCE::Config_Handlers::ResourceUsageKind> (*s.resourceUsage_))
    , requirementName_ (std::make_unique<::XMLSchema::string<char>> (*s.requirementName_))
    , resourceName_ (std::make_unique<::XMLSchema::string<char>> (*s.resourceName_))
    , property_ (s.property_)
    {
    }

    InstanceResourceDeploymentDescription&
    InstanceResourceDeploymentDescription::operator= (InstanceResourceDeploymentDescription const& s)
    {
      if (std::addressof(s) != this)
      {
        resourceUsage (*s.resourceUsage_);

        requirementName (*s.requirementName_);

        resourceName (*s.resourceName_);

        property_ = s.property_;
      }

      return *this;
    }


    // InstanceResourceDeploymentDescription
    ::DAnCE::Config_Handlers::ResourceUsageKind const& InstanceResourceDeploymentDescription::
    resourceUsage () const
    {
      return *resourceUsage_;
    }

    void InstanceResourceDeploymentDescription::
    resourceUsage (::DAnCE::Config_Handlers::ResourceUsageKind const& e)
    {
      *resourceUsage_ = e;
    }

    // InstanceResourceDeploymentDescription
    ::XMLSchema::string<char> const& InstanceResourceDeploymentDescription::
    requirementName () const
    {
      return *requirementName_;
    }

    void InstanceResourceDeploymentDescription::
    requirementName (::XMLSchema::string<char> const& e)
    {
      *requirementName_ = e;
    }

    // InstanceResourceDeploymentDescription
    ::XMLSchema::string<char> const& InstanceResourceDeploymentDescription::
    resourceName () const
    {
      return *resourceName_;
    }

    void InstanceResourceDeploymentDescription::
    resourceName (::XMLSchema::string<char> const& e)
    {
      *resourceName_ = e;
    }

    // InstanceResourceDeploymentDescription
    InstanceResourceDeploymentDescription::property_const_iterator InstanceResourceDeploymentDescription::
    begin_property () const
    {
      return property_.cbegin ();
    }

    InstanceResourceDeploymentDescription::property_const_iterator InstanceResourceDeploymentDescription::
    end_property () const
    {
      return property_.cend ();
    }

    size_t InstanceResourceDeploymentDescription::
    count_property() const
    {
      return property_.size ();
    }


    // InstanceDeploymentDescription

    InstanceDeploymentDescription::InstanceDeploymentDescription (::XMLSchema::string<char> const& name__,
                                                                  ::XMLSchema::string<char> const& node__,
                                                                  ::XMLSchema::string<char> const& source__,
                                                                  ::DAnCE::Config_Handlers::IdRef const& implementation__)
    : ::XSCRT::Type ()
    , name_ (std::make_unique<::XMLSchema::string<char>> (name__))
    , node_ (std::make_unique<::XMLSchema::string<char>> (node__))
    , source_ (std::make_unique<::XMLSchema::string<char>> (source__))
    , implementation_ (std::make_unique<::DAnCE::Config_Handlers::IdRef> (implementation__))
    {
    }

    InstanceDeploymentDescription::InstanceDeploymentDescription (InstanceDeploymentDescription const& s) :
    ::XSCRT::Type (s)
    , name_ (std::make_unique<::XMLSchema::string<char>> (*s.name_))
    , node_ (std::make_unique<::XMLSchema::string<char>> (*s.node_))
    , source_ (std::make_unique<::XMLSchema::string<char>> (*s.source_))
    , implementation_ (std::make_unique<::DAnCE::Config_Handlers::IdRef> (*s.implementation_))
    , configProperty_ (s.configProperty_)
    , deployedResource_ (s.deployedResource_)
    , deployedSharedResource_ (s.deployedSharedResource_)
    , id_ (s.id_ ? std::make_unique<::XMLSchema::ID<char>> (*s.id_) : nullptr)
    {
    }

    InstanceDeploymentDescription&
    InstanceDeploymentDescription::operator= (InstanceDeploymentDescription const& s)
    {
      if (std::addressof(s) != this)
      {
        name (*s.name_);

        node (*s.node_);

        source (*s.source_);

        implementation (*s.implementation_);

        configProperty_ = s.configProperty_;

        deployedResource_ = s.deployedResource_;

        deployedSharedResource_ = s.deployedSharedResource_;

        if (s.id_) id (*(s.id_));
        else id_.release ();
      }

      return *this;
    }


    // InstanceDeploymentDescription
    ::XMLSchema::string<char> const& InstanceDeploymentDescription::
    name () const
    {
      return *name_;
    }

    void InstanceDeploymentDescription::
    name (::XMLSchema::string<char> const& e)
    {
      *name_ = e;
    }

    // InstanceDeploymentDescription
    ::XMLSchema::string<char> const& InstanceDeploymentDescription::
    node () const
    {
      return *node_;
    }

    void InstanceDeploymentDescription::
    node (::XMLSchema::string<char> const& e)
    {
      *node_ = e;
    }

    // InstanceDeploymentDescription
    ::XMLSchema::string<char> const& InstanceDeploymentDescription::
    source () const
    {
      return *source_;
    }

    void InstanceDeploymentDescription::
    source (::XMLSchema::string<char> const& e)
    {
      *source_ = e;
    }

    // InstanceDeploymentDescription
    ::DAnCE::Config_Handlers::IdRef const& InstanceDeploymentDescription::
    implementation () const
    {
      return *implementation_;
    }

    void InstanceDeploymentDescription::
    implementation (::DAnCE::Config_Handlers::IdRef const& e)
    {
      *implementation_ = e;
    }

    // InstanceDeploymentDescription
    InstanceDeploymentDescription::configProperty_const_iterator InstanceDeploymentDescription::
    begin_configProperty () const
    {
      return configProperty_.cbegin ();
    }

    InstanceDeploymentDescription::configProperty_const_iterator InstanceDeploymentDescription::
    end_configProperty () const
    {
      return configProperty_.cend ();
    }

    size_t InstanceDeploymentDescription::
    count_configProperty() const
    {
      return configProperty_.size ();
    }

    // InstanceDeploymentDescription
    InstanceDeploymentDescription::deployedResource_const_iterator InstanceDeploymentDescription::
    begin_deployedResource () const
    {
      return deployedResource_.cbegin ();
    }

    InstanceDeploymentDescription::deployedResource_const_iterator InstanceDeploymentDescription::
    end_deployedResource () const
    {
      return deployedResource_.cend ();
    }

    size_t InstanceDeploymentDescription::
    count_deployedResource() const
    {
      return deployedResource_.size ();
    }

    // InstanceDeploymentDescription
    InstanceDeploymentDescription::deployedSharedResource_const_iterator InstanceDeploymentDescription::
    begin_deployedSharedResource () const
    {
      return deployedSharedResource_.cbegin ();
    }

    InstanceDeploymentDescription::deployedSharedResource_const_iterator InstanceDeploymentDescription::
    end_deployedSharedResource () const
    {
      return deployedSharedResource_.cend ();
    }

    size_t InstanceDeploymentDescription::
    count_deployedSharedResource() const
    {
      return deployedSharedResource_.size ();
    }

    // InstanceDeploymentDescription
    bool InstanceDeploymentDescription::
    id_p () const
    {
      return !!id_;
    }

    ::XMLSchema::ID<char> const& InstanceDeploymentDescription::
    id () const
    {
      return *id_;
    }

    ::XMLSchema::ID<char>& InstanceDeploymentDescription::
    id ()
    {
      return *id_;
    }

    void InstanceDeploymentDescription::
    id (::XMLSchema::ID<char> const& e)
    {
      if (id_)
      {
        *id_ = e;
      }

      else
      {
        id_ = std::make_unique<::XMLSchema::ID<char>> (e);
      }
    }


    // CCMComponentPortKind

    CCMComponentPortKind::Value CCMComponentPortKind::
    integral () const
    {
      return v_;
    }

    bool
    operator== (::DAnCE::Config_Handlers::CCMComponentPortKind const& a, ::DAnCE::Config_Handlers::CCMComponentPortKind const& b)
    {
      return a.v_ == b.v_;
    }

    bool
    operator!= (::DAnCE::Config_Handlers::CCMComponentPortKind const& a, ::DAnCE::Config_Handlers::CCMComponentPortKind const& b)
    {
      return a.v_ != b.v_;
    }

    CCMComponentPortKind::
    CCMComponentPortKind (CCMComponentPortKind::Value v)
    : v_ (v)
    {
    }

    // ComponentPortDescription

    ComponentPortDescription::ComponentPortDescription (::XMLSchema::string<char> const& name__,
                                                        ::XMLSchema::boolean const& provider__,
                                                        ::XMLSchema::boolean const& exclusiveProvider__,
                                                        ::XMLSchema::boolean const& exclusiveUser__,
                                                        ::XMLSchema::boolean const& optional__,
                                                        ::DAnCE::Config_Handlers::CCMComponentPortKind const& kind__)
    : ::XSCRT::Type ()
    , name_ (std::make_unique<::XMLSchema::string<char>> (name__))
    , provider_ (std::make_unique<::XMLSchema::boolean> (provider__))
    , exclusiveProvider_ (std::make_unique<::XMLSchema::boolean> (exclusiveProvider__))
    , exclusiveUser_ (std::make_unique<::XMLSchema::boolean> (exclusiveUser__))
    , optional_ (std::make_unique<::XMLSchema::boolean> (optional__))
    , kind_ (std::make_unique<::DAnCE::Config_Handlers::CCMComponentPortKind> (kind__))
    {
    }

    ComponentPortDescription::ComponentPortDescription (ComponentPortDescription const& s) :
    ::XSCRT::Type (s)
    , name_ (std::make_unique<::XMLSchema::string<char>> (*s.name_))
    , specificType_ (s.specificType_ ? std::make_unique<::XMLSchema::string<char>> (*s.specificType_) : nullptr)
    , supportedType_ (s.supportedType_)
    , provider_ (std::make_unique<::XMLSchema::boolean> (*s.provider_))
    , exclusiveProvider_ (std::make_unique<::XMLSchema::boolean> (*s.exclusiveProvider_))
    , exclusiveUser_ (std::make_unique<::XMLSchema::boolean> (*s.exclusiveUser_))
    , optional_ (std::make_unique<::XMLSchema::boolean> (*s.optional_))
    , kind_ (std::make_unique<::DAnCE::Config_Handlers::CCMComponentPortKind> (*s.kind_))
    , templateParam_ (s.templateParam_)
    {
    }

    ComponentPortDescription&
    ComponentPortDescription::operator= (ComponentPortDescription const& s)
    {
      if (std::addressof(s) != this)
      {
        name (*s.name_);

        if (s.specificType_)
          specificType (*(s.specificType_));
        else
          specificType_.release ();

        supportedType_ = s.supportedType_;

        provider (*s.provider_);

        exclusiveProvider (*s.exclusiveProvider_);

        exclusiveUser (*s.exclusiveUser_);

        optional (*s.optional_);

        kind (*s.kind_);

        templateParam_ = s.templateParam_;
      }

      return *this;
    }


    // ComponentPortDescription
    ::XMLSchema::string<char> const& ComponentPortDescription::
    name () const
    {
      return *name_;
    }

    void ComponentPortDescription::
    name (::XMLSchema::string<char> const& e)
    {
      *name_ = e;
    }

    // ComponentPortDescription
    bool ComponentPortDescription::
    specificType_p () const
    {
      return !!specificType_;
    }

    ::XMLSchema::string<char> const& ComponentPortDescription::
    specificType () const
    {
      return *specificType_;
    }

    void ComponentPortDescription::
    specificType (::XMLSchema::string<char> const& e)
    {
      if (specificType_)
      {
        *specificType_ = e;
      }

      else
      {
        specificType_ = std::make_unique<::XMLSchema::string<char>> (e);
      }
    }

    // ComponentPortDescription
    ComponentPortDescription::supportedType_const_iterator ComponentPortDescription::
    begin_supportedType () const
    {
      return supportedType_.cbegin ();
    }

    ComponentPortDescription::supportedType_const_iterator ComponentPortDescription::
    end_supportedType () const
    {
      return supportedType_.cend ();
    }

    size_t ComponentPortDescription::
    count_supportedType() const
    {
      return supportedType_.size ();
    }

    // ComponentPortDescription
    ::XMLSchema::boolean const& ComponentPortDescription::
    provider () const
    {
      return *provider_;
    }

    void ComponentPortDescription::
    provider (::XMLSchema::boolean const& e)
    {
      *provider_ = e;
    }

    // ComponentPortDescription
    ::XMLSchema::boolean const& ComponentPortDescription::
    exclusiveProvider () const
    {
      return *exclusiveProvider_;
    }

    void ComponentPortDescription::
    exclusiveProvider (::XMLSchema::boolean const& e)
    {
      *exclusiveProvider_ = e;
    }

    // ComponentPortDescription
    ::XMLSchema::boolean const& ComponentPortDescription::
    exclusiveUser () const
    {
      return *exclusiveUser_;
    }

    void ComponentPortDescription::
    exclusiveUser (::XMLSchema::boolean const& e)
    {
      *exclusiveUser_ = e;
    }

    // ComponentPortDescription
    ::XMLSchema::boolean const& ComponentPortDescription::
    optional () const
    {
      return *optional_;
    }

    void ComponentPortDescription::
    optional (::XMLSchema::boolean const& e)
    {
      *optional_ = e;
    }

    // ComponentPortDescription
    ::DAnCE::Config_Handlers::CCMComponentPortKind const& ComponentPortDescription::
    kind () const
    {
      return *kind_;
    }

    void ComponentPortDescription::
    kind (::DAnCE::Config_Handlers::CCMComponentPortKind const& e)
    {
      *kind_ = e;
    }

    // ComponentPortDescription
    ComponentPortDescription::templateParam_const_iterator ComponentPortDescription::
    begin_templateParam () const
    {
      return templateParam_.cbegin ();
    }

    ComponentPortDescription::templateParam_const_iterator ComponentPortDescription::
    end_templateParam () const
    {
      return templateParam_.cend ();
    }

    size_t ComponentPortDescription::
    count_templateParam() const
    {
      return templateParam_.size ();
    }


    // ComponentPropertyDescription

    ComponentPropertyDescription::ComponentPropertyDescription (::XMLSchema::string<char> const& name__,
                                                                ::DAnCE::Config_Handlers::DataType const& type__)
    : ::XSCRT::Type ()
    , name_ (std::make_unique<::XMLSchema::string<char>> (name__))
    , type_ (std::make_unique<::DAnCE::Config_Handlers::DataType> (type__))
    {
    }

    ComponentPropertyDescription::ComponentPropertyDescription (ComponentPropertyDescription const& s) :
    ::XSCRT::Type (s)
    , name_ (std::make_unique<::XMLSchema::string<char>> (*s.name_))
    , type_ (std::make_unique<::DAnCE::Config_Handlers::DataType> (*s.type_))
    {
    }

    ComponentPropertyDescription&
    ComponentPropertyDescription::operator= (ComponentPropertyDescription const& s)
    {
      if (std::addressof(s) != this)
      {
        name (*s.name_);

        type (*s.type_);
      }

      return *this;
    }


    // ComponentPropertyDescription
    ::XMLSchema::string<char> const& ComponentPropertyDescription::
    name () const
    {
      return *name_;
    }

    void ComponentPropertyDescription::
    name (::XMLSchema::string<char> const& e)
    {
      *name_ = e;
    }

    // ComponentPropertyDescription
    ::DAnCE::Config_Handlers::DataType const& ComponentPropertyDescription::
    type () const
    {
      return *type_;
    }

    void ComponentPropertyDescription::
    type (::DAnCE::Config_Handlers::DataType const& e)
    {
      *type_ = e;
    }


    // ComponentExternalPortEndpoint

    ComponentExternalPortEndpoint::ComponentExternalPortEndpoint (::XMLSchema::string<char> const& portName__)
    : ::XSCRT::Type ()
    , portName_ (std::make_unique<::XMLSchema::string<char>> (portName__))
    {
    }

    ComponentExternalPortEndpoint::ComponentExternalPortEndpoint (ComponentExternalPortEndpoint const& s) :
    ::XSCRT::Type (s)
    , portName_ (std::make_unique<::XMLSchema::string<char>> (*s.portName_))
    {
    }

    ComponentExternalPortEndpoint&
    ComponentExternalPortEndpoint::operator= (ComponentExternalPortEndpoint const& s)
    {
      if (std::addressof(s) != this)
      {
        portName (*s.portName_);
      }

      return *this;
    }


    // ComponentExternalPortEndpoint
    ::XMLSchema::string<char> const& ComponentExternalPortEndpoint::
    portName () const
    {
      return *portName_;
    }

    void ComponentExternalPortEndpoint::
    portName (::XMLSchema::string<char> const& e)
    {
      *portName_ = e;
    }


    // PlanSubcomponentPortEndpoint

    PlanSubcomponentPortEndpoint::PlanSubcomponentPortEndpoint (::XMLSchema::string<char> const& portName__,
                                                                ::DAnCE::Config_Handlers::CCMComponentPortKind const& kind__,
                                                                ::DAnCE::Config_Handlers::IdRef const& instance__)
    : ::XSCRT::Type ()
    , portName_ (std::make_unique<::XMLSchema::string<char>> (portName__))
    , kind_ (std::make_unique<::DAnCE::Config_Handlers::CCMComponentPortKind> (kind__))
    , instance_ (std::make_unique<::DAnCE::Config_Handlers::IdRef> (instance__))
    {
    }

    PlanSubcomponentPortEndpoint::PlanSubcomponentPortEndpoint (PlanSubcomponentPortEndpoint const& s) :
    ::XSCRT::Type (s)
    , portName_ (std::make_unique<::XMLSchema::string<char>> (*s.portName_))
    , provider_ (s.provider_ ? std::make_unique<::XMLSchema::string<char>> (*s.provider_) : nullptr)
    , kind_ (std::make_unique<::DAnCE::Config_Handlers::CCMComponentPortKind> (*s.kind_))
    , instance_ (std::make_unique<::DAnCE::Config_Handlers::IdRef> (*s.instance_))
    {
    }

    PlanSubcomponentPortEndpoint&
    PlanSubcomponentPortEndpoint::operator= (PlanSubcomponentPortEndpoint const& s)
    {
      if (std::addressof(s) != this)
      {
        portName (*s.portName_);

        if (s.provider_)
          provider (*(s.provider_));
        else
          provider_.release ();

        kind (*s.kind_);

        instance (*s.instance_);
      }

      return *this;
    }


    // PlanSubcomponentPortEndpoint
    ::XMLSchema::string<char> const& PlanSubcomponentPortEndpoint::
    portName () const
    {
      return *portName_;
    }

    void PlanSubcomponentPortEndpoint::
    portName (::XMLSchema::string<char> const& e)
    {
      *portName_ = e;
    }

    // PlanSubcomponentPortEndpoint
    bool PlanSubcomponentPortEndpoint::
    provider_p () const
    {
      return !!provider_;
    }

    ::XMLSchema::string<char> const& PlanSubcomponentPortEndpoint::
    provider () const
    {
      return *provider_;
    }

    void PlanSubcomponentPortEndpoint::
    provider (::XMLSchema::string<char> const& e)
    {
      if (provider_)
      {
        *provider_ = e;
      }

      else
      {
        provider_ = std::make_unique<::XMLSchema::string<char>> (e);
      }
    }

    // PlanSubcomponentPortEndpoint
    ::DAnCE::Config_Handlers::CCMComponentPortKind const& PlanSubcomponentPortEndpoint::
    kind () const
    {
      return *kind_;
    }

    void PlanSubcomponentPortEndpoint::
    kind (::DAnCE::Config_Handlers::CCMComponentPortKind const& e)
    {
      *kind_ = e;
    }

    // PlanSubcomponentPortEndpoint
    ::DAnCE::Config_Handlers::IdRef const& PlanSubcomponentPortEndpoint::
    instance () const
    {
      return *instance_;
    }

    void PlanSubcomponentPortEndpoint::
    instance (::DAnCE::Config_Handlers::IdRef const& e)
    {
      *instance_ = e;
    }


    // ExternalReferenceEndpoint

    ExternalReferenceEndpoint::ExternalReferenceEndpoint (::XMLSchema::string<char> const& location__,
                                                          ::XMLSchema::boolean const& provider__)
    : ::XSCRT::Type ()
    , location_ (std::make_unique<::XMLSchema::string<char>> (location__))
    , provider_ (std::make_unique<::XMLSchema::boolean> (provider__))
    {
    }

    ExternalReferenceEndpoint::ExternalReferenceEndpoint (ExternalReferenceEndpoint const& s) :
    ::XSCRT::Type (s)
    , location_ (std::make_unique<::XMLSchema::string<char>> (*s.location_))
    , provider_ (std::make_unique<::XMLSchema::boolean> (*s.provider_))
    , portName_ (s.portName_ ? std::make_unique<::XMLSchema::string<char>> (*s.portName_) : nullptr)
    , supportedType_ (s.supportedType_)
    {
    }

    ExternalReferenceEndpoint&
    ExternalReferenceEndpoint::operator= (ExternalReferenceEndpoint const& s)
    {
      if (std::addressof(s) != this)
      {
        location (*s.location_);

        provider (*s.provider_);

        if (s.portName_)
          portName (*(s.portName_));
        else
          portName_.release ();

        supportedType_ = s.supportedType_;
      }

      return *this;
    }


    // ExternalReferenceEndpoint
    ::XMLSchema::string<char> const& ExternalReferenceEndpoint::
    location () const
    {
      return *location_;
    }

    void ExternalReferenceEndpoint::
    location (::XMLSchema::string<char> const& e)
    {
      *location_ = e;
    }

    // ExternalReferenceEndpoint
    ::XMLSchema::boolean const& ExternalReferenceEndpoint::
    provider () const
    {
      return *provider_;
    }

    void ExternalReferenceEndpoint::
    provider (::XMLSchema::boolean const& e)
    {
      *provider_ = e;
    }

    // ExternalReferenceEndpoint
    bool ExternalReferenceEndpoint::
    portName_p () const
    {
      return !!portName_;
    }

    ::XMLSchema::string<char> const& ExternalReferenceEndpoint::
    portName () const
    {
      return *portName_;
    }

    void ExternalReferenceEndpoint::
    portName (::XMLSchema::string<char> const& e)
    {
      if (portName_)
      {
        *portName_ = e;
      }

      else
      {
        portName_ = std::make_unique<::XMLSchema::string<char>> (e);
      }
    }

    // ExternalReferenceEndpoint
    ExternalReferenceEndpoint::supportedType_const_iterator ExternalReferenceEndpoint::
    begin_supportedType () const
    {
      return supportedType_.cbegin ();
    }

    ExternalReferenceEndpoint::supportedType_const_iterator ExternalReferenceEndpoint::
    end_supportedType () const
    {
      return supportedType_.cend ();
    }

    size_t ExternalReferenceEndpoint::
    count_supportedType() const
    {
      return supportedType_.size ();
    }


    // ConnectionResourceDeploymentDescription

    ConnectionResourceDeploymentDescription::ConnectionResourceDeploymentDescription (::XMLSchema::string<char> const& targetName__,
                                                                                      ::XMLSchema::string<char> const& requirementName__,
                                                                                      ::XMLSchema::string<char> const& resourceName__)
    : ::XSCRT::Type ()
    , targetName_ (std::make_unique<::XMLSchema::string<char>> (targetName__))
    , requirementName_ (std::make_unique<::XMLSchema::string<char>> (requirementName__))
    , resourceName_ (std::make_unique<::XMLSchema::string<char>> (resourceName__))
    {
    }

    ConnectionResourceDeploymentDescription::ConnectionResourceDeploymentDescription (ConnectionResourceDeploymentDescription const& s) :
    ::XSCRT::Type (s)
    , targetName_ (std::make_unique<::XMLSchema::string<char>> (*s.targetName_))
    , requirementName_ (std::make_unique<::XMLSchema::string<char>> (*s.requirementName_))
    , resourceName_ (std::make_unique<::XMLSchema::string<char>> (*s.resourceName_))
    , property_ (s.property_)
    {
    }

    ConnectionResourceDeploymentDescription&
    ConnectionResourceDeploymentDescription::operator= (ConnectionResourceDeploymentDescription const& s)
    {
      if (std::addressof(s) != this)
      {
        targetName (*s.targetName_);

        requirementName (*s.requirementName_);

        resourceName (*s.resourceName_);

        property_ = s.property_;
      }

      return *this;
    }


    // ConnectionResourceDeploymentDescription
    ::XMLSchema::string<char> const& ConnectionResourceDeploymentDescription::
    targetName () const
    {
      return *targetName_;
    }

    void ConnectionResourceDeploymentDescription::
    targetName (::XMLSchema::string<char> const& e)
    {
      *targetName_ = e;
    }

    // ConnectionResourceDeploymentDescription
    ::XMLSchema::string<char> const& ConnectionResourceDeploymentDescription::
    requirementName () const
    {
      return *requirementName_;
    }

    void ConnectionResourceDeploymentDescription::
    requirementName (::XMLSchema::string<char> const& e)
    {
      *requirementName_ = e;
    }

    // ConnectionResourceDeploymentDescription
    ::XMLSchema::string<char> const& ConnectionResourceDeploymentDescription::
    resourceName () const
    {
      return *resourceName_;
    }

    void ConnectionResourceDeploymentDescription::
    resourceName (::XMLSchema::string<char> const& e)
    {
      *resourceName_ = e;
    }

    // ConnectionResourceDeploymentDescription
    ConnectionResourceDeploymentDescription::property_const_iterator ConnectionResourceDeploymentDescription::
    begin_property () const
    {
      return property_.cbegin ();
    }

    ConnectionResourceDeploymentDescription::property_const_iterator ConnectionResourceDeploymentDescription::
    end_property () const
    {
      return property_.cend ();
    }

    size_t ConnectionResourceDeploymentDescription::
    count_property() const
    {
      return property_.size ();
    }


    // PlanConnectionDescription

    PlanConnectionDescription::PlanConnectionDescription (::XMLSchema::string<char> const& name__)
    : ::XSCRT::Type ()
    , name_ (std::make_unique<::XMLSchema::string<char>> (name__))
    {
    }

    PlanConnectionDescription::PlanConnectionDescription (PlanConnectionDescription const& s) :
    ::XSCRT::Type (s)
    , name_ (std::make_unique<::XMLSchema::string<char>> (*s.name_))
    , source_ (s.source_ ? std::make_unique<::XMLSchema::string<char>> (*s.source_) : nullptr)
    , deployRequirement_ (s.deployRequirement_)
    , externalEndpoint_ (s.externalEndpoint_)
    , internalEndpoint_ (s.internalEndpoint_)
    , externalReference_ (s.externalReference_)
    , deployedResource_ (s.deployedResource_)
    {
    }

    PlanConnectionDescription&
    PlanConnectionDescription::operator= (PlanConnectionDescription const& s)
    {
      if (std::addressof(s) != this)
      {
        name (*s.name_);

        if (s.source_)
          source (*(s.source_));
        else
          source_.release ();

        deployRequirement_ = s.deployRequirement_;

        externalEndpoint_ = s.externalEndpoint_;

        internalEndpoint_ = s.internalEndpoint_;

        externalReference_ = s.externalReference_;

        deployedResource_ = s.deployedResource_;
      }

      return *this;
    }


    // PlanConnectionDescription
    ::XMLSchema::string<char> const& PlanConnectionDescription::
    name () const
    {
      return *name_;
    }

    void PlanConnectionDescription::
    name (::XMLSchema::string<char> const& e)
    {
      *name_ = e;
    }

    // PlanConnectionDescription
    bool PlanConnectionDescription::
    source_p () const
    {
      return !!source_;
    }

    ::XMLSchema::string<char> const& PlanConnectionDescription::
    source () const
    {
      return *source_;
    }

    void PlanConnectionDescription::
    source (::XMLSchema::string<char> const& e)
    {
      if (source_)
      {
        *source_ = e;
      }

      else
      {
        source_ = std::make_unique<::XMLSchema::string<char>> (e);
      }
    }

    // PlanConnectionDescription
    PlanConnectionDescription::deployRequirement_const_iterator PlanConnectionDescription::
    begin_deployRequirement () const
    {
      return deployRequirement_.cbegin ();
    }

    PlanConnectionDescription::deployRequirement_const_iterator PlanConnectionDescription::
    end_deployRequirement () const
    {
      return deployRequirement_.cend ();
    }

    size_t PlanConnectionDescription::
    count_deployRequirement() const
    {
      return deployRequirement_.size ();
    }

    // PlanConnectionDescription
    PlanConnectionDescription::externalEndpoint_const_iterator PlanConnectionDescription::
    begin_externalEndpoint () const
    {
      return externalEndpoint_.cbegin ();
    }

    PlanConnectionDescription::externalEndpoint_const_iterator PlanConnectionDescription::
    end_externalEndpoint () const
    {
      return externalEndpoint_.cend ();
    }

    size_t PlanConnectionDescription::
    count_externalEndpoint() const
    {
      return externalEndpoint_.size ();
    }

    // PlanConnectionDescription
    PlanConnectionDescription::internalEndpoint_const_iterator PlanConnectionDescription::
    begin_internalEndpoint () const
    {
      return internalEndpoint_.cbegin ();
    }

    PlanConnectionDescription::internalEndpoint_const_iterator PlanConnectionDescription::
    end_internalEndpoint () const
    {
      return internalEndpoint_.cend ();
    }

    size_t PlanConnectionDescription::
    count_internalEndpoint() const
    {
      return internalEndpoint_.size ();
    }

    // PlanConnectionDescription
    PlanConnectionDescription::externalReference_const_iterator PlanConnectionDescription::
    begin_externalReference () const
    {
      return externalReference_.cbegin ();
    }

    PlanConnectionDescription::externalReference_const_iterator PlanConnectionDescription::
    end_externalReference () const
    {
      return externalReference_.cend ();
    }

    size_t PlanConnectionDescription::
    count_externalReference() const
    {
      return externalReference_.size ();
    }

    // PlanConnectionDescription
    PlanConnectionDescription::deployedResource_const_iterator PlanConnectionDescription::
    begin_deployedResource () const
    {
      return deployedResource_.cbegin ();
    }

    PlanConnectionDescription::deployedResource_const_iterator PlanConnectionDescription::
    end_deployedResource () const
    {
      return deployedResource_.cend ();
    }

    size_t PlanConnectionDescription::
    count_deployedResource() const
    {
      return deployedResource_.size ();
    }


    // ImplementationDependency

    ImplementationDependency::ImplementationDependency (::XMLSchema::string<char> const& requiredType__)
    : ::XSCRT::Type ()
    , requiredType_ (std::make_unique<::XMLSchema::string<char>> (requiredType__))
    {
    }

    ImplementationDependency::ImplementationDependency (ImplementationDependency const& s) :
    ::XSCRT::Type (s)
    , requiredType_ (std::make_unique<::XMLSchema::string<char>> (*s.requiredType_))
    {
    }

    ImplementationDependency&
    ImplementationDependency::operator= (ImplementationDependency const& s)
    {
      if (std::addressof(s) != this)
      {
        requiredType (*s.requiredType_);
      }

      return *this;
    }


    // ImplementationDependency
    ::XMLSchema::string<char> const& ImplementationDependency::
    requiredType () const
    {
      return *requiredType_;
    }

    void ImplementationDependency::
    requiredType (::XMLSchema::string<char> const& e)
    {
      *requiredType_ = e;
    }


    // Capability

    Capability::Capability (::XMLSchema::string<char> const& name__)
    : ::XSCRT::Type ()
    , name_ (std::make_unique<::XMLSchema::string<char>> (name__))
    {
    }

    Capability::Capability (Capability const& s) :
    ::XSCRT::Type (s)
    , name_ (std::make_unique<::XMLSchema::string<char>> (*s.name_))
    , resourceType_ (s.resourceType_)
    , property_ (s.property_)
    {
    }

    Capability&
    Capability::operator= (Capability const& s)
    {
      if (std::addressof(s) != this)
      {
        name (*s.name_);

        resourceType_ = s.resourceType_;

        property_ = s.property_;
      }

      return *this;
    }


    // Capability
    ::XMLSchema::string<char> const& Capability::
    name () const
    {
      return *name_;
    }

    void Capability::
    name (::XMLSchema::string<char> const& e)
    {
      *name_ = e;
    }

    // Capability
    Capability::resourceType_const_iterator Capability::
    begin_resourceType () const
    {
      return resourceType_.cbegin ();
    }

    Capability::resourceType_const_iterator Capability::
    end_resourceType () const
    {
      return resourceType_.cend ();
    }

    size_t Capability::
    count_resourceType() const
    {
      return resourceType_.size ();
    }

    // Capability
    Capability::property_const_iterator Capability::
    begin_property () const
    {
      return property_.cbegin ();
    }

    Capability::property_const_iterator Capability::
    end_property () const
    {
      return property_.cend ();
    }

    size_t Capability::
    count_property() const
    {
      return property_.size ();
    }


    // ImplementationRequirement

    ImplementationRequirement::ImplementationRequirement (::XMLSchema::string<char> const& resourceType__,
                                                          ::XMLSchema::string<char> const& name__)
    : ::XSCRT::Type ()
    , resourceType_ (std::make_unique<::XMLSchema::string<char>> (resourceType__))
    , name_ (std::make_unique<::XMLSchema::string<char>> (name__))
    {
    }

    ImplementationRequirement::ImplementationRequirement (ImplementationRequirement const& s) :
    ::XSCRT::Type (s)
    , resourceUsage_ (s.resourceUsage_ ? std::make_unique<::DAnCE::Config_Handlers::ResourceUsageKind> (*s.resourceUsage_) : nullptr)
    , resourcePort_ (s.resourcePort_ ? std::make_unique<::XMLSchema::string<char>> (*s.resourcePort_) : nullptr)
    , componentPort_ (s.componentPort_ ? std::make_unique<::XMLSchema::string<char>> (*s.componentPort_) : nullptr)
    , resourceType_ (std::make_unique<::XMLSchema::string<char>> (*s.resourceType_))
    , name_ (std::make_unique<::XMLSchema::string<char>> (*s.name_))
    , property_ (s.property_)
    {
    }

    ImplementationRequirement&
    ImplementationRequirement::operator= (ImplementationRequirement const& s)
    {
      if (std::addressof(s) != this)
      {
        if (s.resourceUsage_)
          resourceUsage (*(s.resourceUsage_));
        else
          resourceUsage_.release ();

        if (s.resourcePort_)
          resourcePort (*(s.resourcePort_));
        else
          resourcePort_.release ();

        if (s.componentPort_)
          componentPort (*(s.componentPort_));
        else
          componentPort_.release ();

        resourceType (*s.resourceType_);

        name (*s.name_);

        property_ = s.property_;
      }

      return *this;
    }


    // ImplementationRequirement
    bool ImplementationRequirement::
    resourceUsage_p () const
    {
      return !!resourceUsage_;
    }

    ::DAnCE::Config_Handlers::ResourceUsageKind const& ImplementationRequirement::
    resourceUsage () const
    {
      return *resourceUsage_;
    }

    void ImplementationRequirement::
    resourceUsage (::DAnCE::Config_Handlers::ResourceUsageKind const& e)
    {
      if (resourceUsage_)
      {
        *resourceUsage_ = e;
      }

      else
      {
        resourceUsage_ = std::make_unique<::DAnCE::Config_Handlers::ResourceUsageKind> (e);
      }
    }

    // ImplementationRequirement
    bool ImplementationRequirement::
    resourcePort_p () const
    {
      return !!resourcePort_;
    }

    ::XMLSchema::string<char> const& ImplementationRequirement::
    resourcePort () const
    {
      return *resourcePort_;
    }

    void ImplementationRequirement::
    resourcePort (::XMLSchema::string<char> const& e)
    {
      if (resourcePort_)
      {
        *resourcePort_ = e;
      }

      else
      {
        resourcePort_ = std::make_unique<::XMLSchema::string<char>> (e);
      }
    }

    // ImplementationRequirement
    bool ImplementationRequirement::
    componentPort_p () const
    {
      return !!componentPort_;
    }

    ::XMLSchema::string<char> const& ImplementationRequirement::
    componentPort () const
    {
      return *componentPort_;
    }

    void ImplementationRequirement::
    componentPort (::XMLSchema::string<char> const& e)
    {
      if (componentPort_)
      {
        *componentPort_ = e;
      }

      else
      {
        componentPort_ = std::make_unique<::XMLSchema::string<char>> (e);
      }
    }

    // ImplementationRequirement
    ::XMLSchema::string<char> const& ImplementationRequirement::
    resourceType () const
    {
      return *resourceType_;
    }

    void ImplementationRequirement::
    resourceType (::XMLSchema::string<char> const& e)
    {
      *resourceType_ = e;
    }

    // ImplementationRequirement
    ::XMLSchema::string<char> const& ImplementationRequirement::
    name () const
    {
      return *name_;
    }

    void ImplementationRequirement::
    name (::XMLSchema::string<char> const& e)
    {
      *name_ = e;
    }

    // ImplementationRequirement
    ImplementationRequirement::property_const_iterator ImplementationRequirement::
    begin_property () const
    {
      return property_.cbegin ();
    }

    ImplementationRequirement::property_const_iterator ImplementationRequirement::
    end_property () const
    {
      return property_.cend ();
    }

    size_t ImplementationRequirement::
    count_property() const
    {
      return property_.size ();
    }


    // SubcomponentPortEndpoint

    SubcomponentPortEndpoint::SubcomponentPortEndpoint (::XMLSchema::string<char> const& portName__,
                                                        ::DAnCE::Config_Handlers::IdRef const& instance__)
    : ::XSCRT::Type ()
    , portName_ (std::make_unique<::XMLSchema::string<char>> (portName__))
    , instance_ (std::make_unique<::DAnCE::Config_Handlers::IdRef> (instance__))
    {
    }

    SubcomponentPortEndpoint::SubcomponentPortEndpoint (SubcomponentPortEndpoint const& s) :
    ::XSCRT::Type (s)
    , portName_ (std::make_unique<::XMLSchema::string<char>> (*s.portName_))
    , instance_ (std::make_unique<::DAnCE::Config_Handlers::IdRef> (*s.instance_))
    {
    }

    SubcomponentPortEndpoint&
    SubcomponentPortEndpoint::operator= (SubcomponentPortEndpoint const& s)
    {
      if (std::addressof(s) != this)
      {
        portName (*s.portName_);

        instance (*s.instance_);
      }

      return *this;
    }


    // SubcomponentPortEndpoint
    ::XMLSchema::string<char> const& SubcomponentPortEndpoint::
    portName () const
    {
      return *portName_;
    }

    void SubcomponentPortEndpoint::
    portName (::XMLSchema::string<char> const& e)
    {
      *portName_ = e;
    }

    // SubcomponentPortEndpoint
    ::DAnCE::Config_Handlers::IdRef const& SubcomponentPortEndpoint::
    instance () const
    {
      return *instance_;
    }

    void SubcomponentPortEndpoint::
    instance (::DAnCE::Config_Handlers::IdRef const& e)
    {
      *instance_ = e;
    }


    // AssemblyConnectionDescription

    AssemblyConnectionDescription::AssemblyConnectionDescription (::XMLSchema::string<char> const& name__)
    : ::XSCRT::Type ()
    , name_ (std::make_unique<::XMLSchema::string<char>> (name__))
    {
    }

    AssemblyConnectionDescription::AssemblyConnectionDescription (AssemblyConnectionDescription const& s) :
    ::XSCRT::Type (s)
    , name_ (std::make_unique<::XMLSchema::string<char>> (*s.name_))
    , deployRequirement_ (s.deployRequirement_)
    , internalEndpoint_ (s.internalEndpoint_)
    , externalEndpoint_ (s.externalEndpoint_)
    , externalReference_ (s.externalReference_)
    {
    }

    AssemblyConnectionDescription&
    AssemblyConnectionDescription::operator= (AssemblyConnectionDescription const& s)
    {
      if (std::addressof(s) != this)
      {
        name (*s.name_);

        deployRequirement_ = s.deployRequirement_;

        internalEndpoint_ = s.internalEndpoint_;

        externalEndpoint_ = s.externalEndpoint_;

        externalReference_ = s.externalReference_;
      }

      return *this;
    }


    // AssemblyConnectionDescription
    ::XMLSchema::string<char> const& AssemblyConnectionDescription::
    name () const
    {
      return *name_;
    }

    void AssemblyConnectionDescription::
    name (::XMLSchema::string<char> const& e)
    {
      *name_ = e;
    }

    // AssemblyConnectionDescription
    AssemblyConnectionDescription::deployRequirement_const_iterator AssemblyConnectionDescription::
    begin_deployRequirement () const
    {
      return deployRequirement_.cbegin ();
    }

    AssemblyConnectionDescription::deployRequirement_const_iterator AssemblyConnectionDescription::
    end_deployRequirement () const
    {
      return deployRequirement_.cend ();
    }

    size_t AssemblyConnectionDescription::
    count_deployRequirement() const
    {
      return deployRequirement_.size ();
    }

    // AssemblyConnectionDescription
    AssemblyConnectionDescription::internalEndpoint_const_iterator AssemblyConnectionDescription::
    begin_internalEndpoint () const
    {
      return internalEndpoint_.cbegin ();
    }

    AssemblyConnectionDescription::internalEndpoint_const_iterator AssemblyConnectionDescription::
    end_internalEndpoint () const
    {
      return internalEndpoint_.cend ();
    }

    size_t AssemblyConnectionDescription::
    count_internalEndpoint() const
    {
      return internalEndpoint_.size ();
    }

    // AssemblyConnectionDescription
    AssemblyConnectionDescription::externalEndpoint_const_iterator AssemblyConnectionDescription::
    begin_externalEndpoint () const
    {
      return externalEndpoint_.cbegin ();
    }

    AssemblyConnectionDescription::externalEndpoint_const_iterator AssemblyConnectionDescription::
    end_externalEndpoint () const
    {
      return externalEndpoint_.cend ();
    }

    size_t AssemblyConnectionDescription::
    count_externalEndpoint() const
    {
      return externalEndpoint_.size ();
    }

    // AssemblyConnectionDescription
    AssemblyConnectionDescription::externalReference_const_iterator AssemblyConnectionDescription::
    begin_externalReference () const
    {
      return externalReference_.cbegin ();
    }

    AssemblyConnectionDescription::externalReference_const_iterator AssemblyConnectionDescription::
    end_externalReference () const
    {
      return externalReference_.cend ();
    }

    size_t AssemblyConnectionDescription::
    count_externalReference() const
    {
      return externalReference_.size ();
    }


    // PlanLocalityKind

    PlanLocalityKind::Value PlanLocalityKind::
    integral () const
    {
      return v_;
    }

    bool
    operator== (::DAnCE::Config_Handlers::PlanLocalityKind const& a, ::DAnCE::Config_Handlers::PlanLocalityKind const& b)
    {
      return a.v_ == b.v_;
    }

    bool
    operator!= (::DAnCE::Config_Handlers::PlanLocalityKind const& a, ::DAnCE::Config_Handlers::PlanLocalityKind const& b)
    {
      return a.v_ != b.v_;
    }

    PlanLocalityKind::
    PlanLocalityKind (PlanLocalityKind::Value v)
    : v_ (v)
    {
    }

    // PlanLocality

    PlanLocality::PlanLocality (::DAnCE::Config_Handlers::PlanLocalityKind const& constraint__,
                                constrainedInstance_container_type const& constrainedInstance__)
    : ::XSCRT::Type ()
    , constraint_ (std::make_unique<::DAnCE::Config_Handlers::PlanLocalityKind> (constraint__))
    , constrainedInstance_ (constrainedInstance__)
    {
    }

    PlanLocality::PlanLocality (PlanLocality const& s) :
    ::XSCRT::Type (s)
    , constraint_ (std::make_unique<::DAnCE::Config_Handlers::PlanLocalityKind> (*s.constraint_))
    , constrainedInstance_ (s.constrainedInstance_)
    {
    }

    PlanLocality&
    PlanLocality::operator= (PlanLocality const& s)
    {
      if (std::addressof(s) != this)
      {
        constraint (*s.constraint_);

        constrainedInstance_ = s.constrainedInstance_;
      }

      return *this;
    }


    // PlanLocality
    ::DAnCE::Config_Handlers::PlanLocalityKind const& PlanLocality::
    constraint () const
    {
      return *constraint_;
    }

    void PlanLocality::
    constraint (::DAnCE::Config_Handlers::PlanLocalityKind const& e)
    {
      *constraint_ = e;
    }

    // PlanLocality
    PlanLocality::constrainedInstance_const_iterator PlanLocality::
    begin_constrainedInstance () const
    {
      return constrainedInstance_.cbegin ();
    }

    PlanLocality::constrainedInstance_const_iterator PlanLocality::
    end_constrainedInstance () const
    {
      return constrainedInstance_.cend ();
    }

    size_t PlanLocality::
    count_constrainedInstance() const
    {
      return constrainedInstance_.size ();
    }
  }
}

namespace DAnCE
{
  namespace Config_Handlers
  {
    // IdRef

    IdRef::
    IdRef (::XSCRT::XML::Element<char> const& element)
    :Base (element)
    {

      ::XSCRT::Parser<char> p (element);

      while (p.more_attributes ())
      {
        ::XSCRT::XML::Attribute<char> a (p.next_attribute ());
        std::string n (::XSCRT::XML::uq_name (a.name ()));
        if (n ==  ("href"))
        {
          ::XMLSchema::string<char> t (a);
          href (t);
        }

        else if (n ==  ("idref"))
        {
          ::XMLSchema::IDREF<char> t (a);
          idref (t);
        }

        else
        {
        }
      }
    }

    // TCKind

    TCKind::
    TCKind (::XSCRT::XML::Element<char> const& e)
    : ::XSCRT::Type (e)
    {
      std::string v (e.value ());

      if (v ==  ("tk_null")) v_ = tk_null_l;
      else if (v ==  ("tk_void")) v_ = tk_void_l;
      else if (v ==  ("tk_short")) v_ = tk_short_l;
      else if (v ==  ("tk_long")) v_ = tk_long_l;
      else if (v ==  ("tk_ushort")) v_ = tk_ushort_l;
      else if (v ==  ("tk_ulong")) v_ = tk_ulong_l;
      else if (v ==  ("tk_float")) v_ = tk_float_l;
      else if (v ==  ("tk_double")) v_ = tk_double_l;
      else if (v ==  ("tk_boolean")) v_ = tk_boolean_l;
      else if (v ==  ("tk_char")) v_ = tk_char_l;
      else if (v ==  ("tk_octet")) v_ = tk_octet_l;
      else if (v ==  ("tk_any")) v_ = tk_any_l;
      else if (v ==  ("tk_TypeCode")) v_ = tk_TypeCode_l;
      else if (v ==  ("tk_Principal")) v_ = tk_Principal_l;
      else if (v ==  ("tk_objref")) v_ = tk_objref_l;
      else if (v ==  ("tk_struct")) v_ = tk_struct_l;
      else if (v ==  ("tk_union")) v_ = tk_union_l;
      else if (v ==  ("tk_enum")) v_ = tk_enum_l;
      else if (v ==  ("tk_string")) v_ = tk_string_l;
      else if (v ==  ("tk_sequence")) v_ = tk_sequence_l;
      else if (v ==  ("tk_array")) v_ = tk_array_l;
      else if (v ==  ("tk_alias")) v_ = tk_alias_l;
      else if (v ==  ("tk_except")) v_ = tk_except_l;
      else if (v ==  ("tk_longlong")) v_ = tk_longlong_l;
      else if (v ==  ("tk_ulonglong")) v_ = tk_ulonglong_l;
      else if (v ==  ("tk_longdouble")) v_ = tk_longdouble_l;
      else if (v ==  ("tk_wchar")) v_ = tk_wchar_l;
      else if (v ==  ("tk_wstring")) v_ = tk_wstring_l;
      else if (v ==  ("tk_fixed")) v_ = tk_fixed_l;
      else if (v ==  ("tk_value")) v_ = tk_value_l;
      else if (v ==  ("tk_value_box")) v_ = tk_value_box_l;
      else if (v ==  ("tk_native")) v_ = tk_native_l;
      else if (v ==  ("tk_abstract_interface")) v_ = tk_abstract_interface_l;
      else if (v ==  ("tk_local_interface")) v_ = tk_local_interface_l;
      else if (v ==  ("tk_component")) v_ = tk_component_l;
      else if (v ==  ("tk_home")) v_ = tk_home_l;
      else if (v ==  ("tk_event")) v_ = tk_event_l;
      else
      {
      }
    }

    TCKind::
    TCKind (::XSCRT::XML::Attribute<char> const& a)
    : ::XSCRT::Type (a)
    {
      std::string v (a.value ());

      if (v ==  ("tk_null")) v_ = tk_null_l;
      else if (v ==  ("tk_void")) v_ = tk_void_l;
      else if (v ==  ("tk_short")) v_ = tk_short_l;
      else if (v ==  ("tk_long")) v_ = tk_long_l;
      else if (v ==  ("tk_ushort")) v_ = tk_ushort_l;
      else if (v ==  ("tk_ulong")) v_ = tk_ulong_l;
      else if (v ==  ("tk_float")) v_ = tk_float_l;
      else if (v ==  ("tk_double")) v_ = tk_double_l;
      else if (v ==  ("tk_boolean")) v_ = tk_boolean_l;
      else if (v ==  ("tk_char")) v_ = tk_char_l;
      else if (v ==  ("tk_octet")) v_ = tk_octet_l;
      else if (v ==  ("tk_any")) v_ = tk_any_l;
      else if (v ==  ("tk_TypeCode")) v_ = tk_TypeCode_l;
      else if (v ==  ("tk_Principal")) v_ = tk_Principal_l;
      else if (v ==  ("tk_objref")) v_ = tk_objref_l;
      else if (v ==  ("tk_struct")) v_ = tk_struct_l;
      else if (v ==  ("tk_union")) v_ = tk_union_l;
      else if (v ==  ("tk_enum")) v_ = tk_enum_l;
      else if (v ==  ("tk_string")) v_ = tk_string_l;
      else if (v ==  ("tk_sequence")) v_ = tk_sequence_l;
      else if (v ==  ("tk_array")) v_ = tk_array_l;
      else if (v ==  ("tk_alias")) v_ = tk_alias_l;
      else if (v ==  ("tk_except")) v_ = tk_except_l;
      else if (v ==  ("tk_longlong")) v_ = tk_longlong_l;
      else if (v ==  ("tk_ulonglong")) v_ = tk_ulonglong_l;
      else if (v ==  ("tk_longdouble")) v_ = tk_longdouble_l;
      else if (v ==  ("tk_wchar")) v_ = tk_wchar_l;
      else if (v ==  ("tk_wstring")) v_ = tk_wstring_l;
      else if (v ==  ("tk_fixed")) v_ = tk_fixed_l;
      else if (v ==  ("tk_value")) v_ = tk_value_l;
      else if (v ==  ("tk_value_box")) v_ = tk_value_box_l;
      else if (v ==  ("tk_native")) v_ = tk_native_l;
      else if (v ==  ("tk_abstract_interface")) v_ = tk_abstract_interface_l;
      else if (v ==  ("tk_local_interface")) v_ = tk_local_interface_l;
      else if (v ==  ("tk_component")) v_ = tk_component_l;
      else if (v ==  ("tk_home")) v_ = tk_home_l;
      else if (v ==  ("tk_event")) v_ = tk_event_l;
      else
      {
      }
    }

    TCKind const TCKind::tk_null (TCKind::tk_null_l);
    TCKind const TCKind::tk_void (TCKind::tk_void_l);
    TCKind const TCKind::tk_short (TCKind::tk_short_l);
    TCKind const TCKind::tk_long (TCKind::tk_long_l);
    TCKind const TCKind::tk_ushort (TCKind::tk_ushort_l);
    TCKind const TCKind::tk_ulong (TCKind::tk_ulong_l);
    TCKind const TCKind::tk_float (TCKind::tk_float_l);
    TCKind const TCKind::tk_double (TCKind::tk_double_l);
    TCKind const TCKind::tk_boolean (TCKind::tk_boolean_l);
    TCKind const TCKind::tk_char (TCKind::tk_char_l);
    TCKind const TCKind::tk_octet (TCKind::tk_octet_l);
    TCKind const TCKind::tk_any (TCKind::tk_any_l);
    TCKind const TCKind::tk_TypeCode (TCKind::tk_TypeCode_l);
    TCKind const TCKind::tk_Principal (TCKind::tk_Principal_l);
    TCKind const TCKind::tk_objref (TCKind::tk_objref_l);
    TCKind const TCKind::tk_struct (TCKind::tk_struct_l);
    TCKind const TCKind::tk_union (TCKind::tk_union_l);
    TCKind const TCKind::tk_enum (TCKind::tk_enum_l);
    TCKind const TCKind::tk_string (TCKind::tk_string_l);
    TCKind const TCKind::tk_sequence (TCKind::tk_sequence_l);
    TCKind const TCKind::tk_array (TCKind::tk_array_l);
    TCKind const TCKind::tk_alias (TCKind::tk_alias_l);
    TCKind const TCKind::tk_except (TCKind::tk_except_l);
    TCKind const TCKind::tk_longlong (TCKind::tk_longlong_l);
    TCKind const TCKind::tk_ulonglong (TCKind::tk_ulonglong_l);
    TCKind const TCKind::tk_longdouble (TCKind::tk_longdouble_l);
    TCKind const TCKind::tk_wchar (TCKind::tk_wchar_l);
    TCKind const TCKind::tk_wstring (TCKind::tk_wstring_l);
    TCKind const TCKind::tk_fixed (TCKind::tk_fixed_l);
    TCKind const TCKind::tk_value (TCKind::tk_value_l);
    TCKind const TCKind::tk_value_box (TCKind::tk_value_box_l);
    TCKind const TCKind::tk_native (TCKind::tk_native_l);
    TCKind const TCKind::tk_abstract_interface (TCKind::tk_abstract_interface_l);
    TCKind const TCKind::tk_local_interface (TCKind::tk_local_interface_l);
    TCKind const TCKind::tk_component (TCKind::tk_component_l);
    TCKind const TCKind::tk_home (TCKind::tk_home_l);
    TCKind const TCKind::tk_event (TCKind::tk_event_l);

    // DataType

    DataType::
    DataType (::XSCRT::XML::Element<char> const& element)
    :Base (element)
    {

      ::XSCRT::Parser<char> p (element);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<char> e (p.next_element ());
        std::string n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "kind")
        {
          kind_ = std::make_unique<::DAnCE::Config_Handlers::TCKind> (e);
        }

        else if (n == "enum")
        {
          ::DAnCE::Config_Handlers::EnumType t (e);
          enum_ (t);
        }

        else if (n == "struct")
        {
          ::DAnCE::Config_Handlers::StructType t (e);
          struct_ (t);
        }

        else if (n == "value")
        {
          ::DAnCE::Config_Handlers::ValueType t (e);
          value (t);
        }

        else if (n == "sequence")
        {
          ::DAnCE::Config_Handlers::SequenceType t (e);
          sequence (t);
        }

        else if (n == "alias")
        {
          ::DAnCE::Config_Handlers::AliasType t (e);
          alias (t);
        }

        else if (n == "array")
        {
          ::DAnCE::Config_Handlers::ArrayType t (e);
          array (t);
        }

        else if (n == "boundedString")
        {
          ::DAnCE::Config_Handlers::BoundedStringType t (e);
          boundedString (t);
        }

        else
        {
        }
      }

      while (p.more_attributes ())
      {
        ::XSCRT::XML::Attribute<char> a (p.next_attribute ());
        std::string n (::XSCRT::XML::uq_name (a.name ()));
        if (n ==  ("id"))
        {
          ::XMLSchema::ID<char> t (a);
          id (t);
        }

        else
        {
        }
      }
    }

    // DataValue

    DataValue::
    DataValue (::XSCRT::XML::Element<char> const& element)
    :Base (element)
    {

      ::XSCRT::Parser<char> p (element);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<char> e (p.next_element ());
        std::string n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "short")
        {
          ::XMLSchema::short_ t (e);
          short__.push_back (t);
        }

        else if (n == "long")
        {
          ::XMLSchema::int_ t (e);
          long__.push_back (t);
        }

        else if (n == "ushort")
        {
          ::XMLSchema::unsignedShort t (e);
          ushort_.push_back (t);
        }

        else if (n == "ulong")
        {
          ::XMLSchema::unsignedInt t (e);
          ulong_.push_back (t);
        }

        else if (n == "float")
        {
          ::XMLSchema::float_ t (e);
          float__.push_back (t);
        }

        else if (n == "double")
        {
          ::XMLSchema::double_ t (e);
          double__.push_back (t);
        }

        else if (n == "boolean")
        {
          ::XMLSchema::boolean t (e);
          boolean_.push_back (t);
        }

        else if (n == "octet")
        {
          ::XMLSchema::unsignedByte t (e);
          octet_.push_back (t);
        }

        else if (n == "enum")
        {
          ::XMLSchema::string<char> t (e);
          enum__.push_back (t);
        }

        else if (n == "string")
        {
          ::XMLSchema::string<char> t (e);
          string_.push_back (t);
        }

        else if (n == "longlong")
        {
          ::XMLSchema::long_ t (e);
          longlong_.push_back (t);
        }

        else if (n == "ulonglong")
        {
          ::XMLSchema::unsignedLong t (e);
          ulonglong_.push_back (t);
        }

        else if (n == "longdouble")
        {
          ::XMLSchema::double_ t (e);
          longdouble_.push_back (t);
        }

        else if (n == "element")
        {
          ::DAnCE::Config_Handlers::DataValue t (e);
          element_.push_back (t);
        }

        else if (n == "member")
        {
          ::DAnCE::Config_Handlers::NamedValue t (e);
          member_.push_back (t);
        }

        else
        {
        }
      }
    }

    // AliasType

    AliasType::
    AliasType (::XSCRT::XML::Element<char> const& element)
    :Base (element)
    {

      ::XSCRT::Parser<char> p (element);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<char> e (p.next_element ());
        std::string n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "name")
        {
          name_ = std::make_unique<::XMLSchema::string<char>> (e);
        }

        else if (n == "typeId")
        {
          typeId_ = std::make_unique<::XMLSchema::string<char>> (e);
        }

        else if (n == "elementType")
        {
          elementType_ = std::make_unique<::DAnCE::Config_Handlers::DataType> (e);
        }

        else
        {
        }
      }
    }

    // EnumType

    EnumType::
    EnumType (::XSCRT::XML::Element<char> const& element)
    :Base (element)
    {

      ::XSCRT::Parser<char> p (element);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<char> e (p.next_element ());
        std::string n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "name")
        {
          name_ = std::make_unique<::XMLSchema::string<char>> (e);
        }

        else if (n == "typeId")
        {
          typeId_ = std::make_unique<::XMLSchema::string<char>> (e);
        }

        else if (n == "member")
        {
          ::XMLSchema::string<char> t (e);
          member_.push_back (t);
        }

        else
        {
        }
      }
    }

    // BoundedStringType

    BoundedStringType::
    BoundedStringType (::XSCRT::XML::Element<char> const& element)
    :Base (element)
    {

      ::XSCRT::Parser<char> p (element);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<char> e (p.next_element ());
        std::string n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "bound")
        {
          ::XMLSchema::unsignedInt t (e);
          bound_.push_back (t);
        }

        else
        {
        }
      }
    }

    // StructType

    StructType::
    StructType (::XSCRT::XML::Element<char> const& element)
    :Base (element)
    {

      ::XSCRT::Parser<char> p (element);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<char> e (p.next_element ());
        std::string n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "name")
        {
          name_ = std::make_unique<::XMLSchema::string<char>> (e);
        }

        else if (n == "typeId")
        {
          typeId_ = std::make_unique<::XMLSchema::string<char>> (e);
        }

        else if (n == "member")
        {
          ::DAnCE::Config_Handlers::StructMemberType t (e);
          member_.push_back (t);
        }

        else
        {
        }
      }
    }

    // StructMemberType

    StructMemberType::
    StructMemberType (::XSCRT::XML::Element<char> const& element)
    :Base (element)
    {

      ::XSCRT::Parser<char> p (element);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<char> e (p.next_element ());
        std::string n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "name")
        {
          name_ = std::make_unique<::XMLSchema::string<char>> (e);
        }

        else if (n == "type")
        {
          type_ = std::make_unique<::DAnCE::Config_Handlers::DataType> (e);
        }

        else
        {
        }
      }
    }

    // ValueType

    ValueType::
    ValueType (::XSCRT::XML::Element<char> const& element)
    :Base (element)
    {

      ::XSCRT::Parser<char> p (element);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<char> e (p.next_element ());
        std::string n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "name")
        {
          name_ = std::make_unique<::XMLSchema::string<char>> (e);
        }

        else if (n == "typeId")
        {
          typeId_ = std::make_unique<::XMLSchema::string<char>> (e);
        }

        else if (n == "modifier")
        {
          modifier_ = std::make_unique<::XMLSchema::string<char>> (e);
        }

        else if (n == "baseType")
        {
          baseType_ = std::make_unique<::DAnCE::Config_Handlers::DataType> (e);
        }

        else if (n == "member")
        {
          ::DAnCE::Config_Handlers::ValueMemberType t (e);
          member_.push_back (t);
        }

        else
        {
        }
      }
    }

    // ValueMemberType

    ValueMemberType::
    ValueMemberType (::XSCRT::XML::Element<char> const& element)
    :Base (element)
    {

      ::XSCRT::Parser<char> p (element);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<char> e (p.next_element ());
        std::string n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "name")
        {
          name_ = std::make_unique<::XMLSchema::string<char>> (e);
        }

        else if (n == "visibility")
        {
          visibility_ = std::make_unique<::XMLSchema::string<char>> (e);
        }

        else if (n == "type")
        {
          type_ = std::make_unique<::DAnCE::Config_Handlers::DataType> (e);
        }

        else
        {
        }
      }
    }

    // NamedValue

    NamedValue::
    NamedValue (::XSCRT::XML::Element<char> const& element)
    :Base (element)
    {

      ::XSCRT::Parser<char> p (element);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<char> e (p.next_element ());
        std::string n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "name")
        {
          name_ = std::make_unique<::XMLSchema::string<char>> (e);
        }

        else if (n == "value")
        {
          value_ = std::make_unique<::DAnCE::Config_Handlers::DataValue> (e);
        }

        else
        {
        }
      }
    }

    // ArrayType

    ArrayType::
    ArrayType (::XSCRT::XML::Element<char> const& element)
    :Base (element)
    {

      ::XSCRT::Parser<char> p (element);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<char> e (p.next_element ());
        std::string n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "length")
        {
          length_ = std::make_unique<::XMLSchema::unsignedInt> (e);
        }

        else if (n == "elementType")
        {
          elementType_ = std::make_unique<::DAnCE::Config_Handlers::DataType> (e);
        }

        else
        {
        }
      }
    }

    // SequenceType

    SequenceType::
    SequenceType (::XSCRT::XML::Element<char> const& element)
    :Base (element)
    {

      ::XSCRT::Parser<char> p (element);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<char> e (p.next_element ());
        std::string n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "bound")
        {
          ::XMLSchema::unsignedInt t (e);
          bound (t);
        }

        else if (n == "elementType")
        {
          elementType_ = std::make_unique<::DAnCE::Config_Handlers::DataType> (e);
        }

        else
        {
        }
      }
    }

    // Any

    Any::
    Any (::XSCRT::XML::Element<char> const& element)
    :Base (element)
    {

      ::XSCRT::Parser<char> p (element);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<char> e (p.next_element ());
        std::string n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "type")
        {
          type_ = std::make_unique<::DAnCE::Config_Handlers::DataType> (e);
        }

        else if (n == "value")
        {
          value_ = std::make_unique<::DAnCE::Config_Handlers::DataValue> (e);
        }

        else
        {
        }
      }
    }

    // Property

    Property::
    Property (::XSCRT::XML::Element<char> const& element)
    :Base (element)
    {

      ::XSCRT::Parser<char> p (element);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<char> e (p.next_element ());
        std::string n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "name")
        {
          name_ = std::make_unique<::XMLSchema::string<char>> (e);
        }

        else if (n == "value")
        {
          value_ = std::make_unique<::DAnCE::Config_Handlers::Any> (e);
        }

        else
        {
        }
      }
    }

    // SatisfierPropertyKind

    SatisfierPropertyKind::
    SatisfierPropertyKind (::XSCRT::XML::Element<char> const& e)
    : ::XSCRT::Type (e)
    {
      std::string v (e.value ());

      if (v ==  ("Quantity")) v_ = Quantity_l;
      else if (v ==  ("Capacity")) v_ = Capacity_l;
      else if (v ==  ("Minimum")) v_ = Minimum_l;
      else if (v ==  ("Maximum")) v_ = Maximum_l;
      else if (v ==  ("Attribute")) v_ = Attribute_l;
      else if (v ==  ("Selection")) v_ = Selection_l;
      else
      {
      }
    }

    SatisfierPropertyKind::
    SatisfierPropertyKind (::XSCRT::XML::Attribute<char> const& a)
    : ::XSCRT::Type (a)
    {
      std::string v (a.value ());

      if (v ==  ("Quantity")) v_ = Quantity_l;
      else if (v ==  ("Capacity")) v_ = Capacity_l;
      else if (v ==  ("Minimum")) v_ = Minimum_l;
      else if (v ==  ("Maximum")) v_ = Maximum_l;
      else if (v ==  ("Attribute")) v_ = Attribute_l;
      else if (v ==  ("Selection")) v_ = Selection_l;
      else
      {
      }
    }

    SatisfierPropertyKind const SatisfierPropertyKind::Quantity (SatisfierPropertyKind::Quantity_l);
    SatisfierPropertyKind const SatisfierPropertyKind::Capacity (SatisfierPropertyKind::Capacity_l);
    SatisfierPropertyKind const SatisfierPropertyKind::Minimum (SatisfierPropertyKind::Minimum_l);
    SatisfierPropertyKind const SatisfierPropertyKind::Maximum (SatisfierPropertyKind::Maximum_l);
    SatisfierPropertyKind const SatisfierPropertyKind::Attribute (SatisfierPropertyKind::Attribute_l);
    SatisfierPropertyKind const SatisfierPropertyKind::Selection (SatisfierPropertyKind::Selection_l);

    // SatisfierProperty

    SatisfierProperty::
    SatisfierProperty (::XSCRT::XML::Element<char> const& element)
    :Base (element)
    {

      ::XSCRT::Parser<char> p (element);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<char> e (p.next_element ());
        std::string n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "name")
        {
          name_ = std::make_unique<::XMLSchema::string<char>> (e);
        }

        else if (n == "kind")
        {
          kind_ = std::make_unique<::DAnCE::Config_Handlers::SatisfierPropertyKind> (e);
        }

        else if (n == "dynamic")
        {
          dynamic_ = std::make_unique<::XMLSchema::boolean> (e);
        }

        else if (n == "value")
        {
          value_ = std::make_unique<::DAnCE::Config_Handlers::Any> (e);
        }

        else
        {
        }
      }
    }

    // Resource

    Resource::
    Resource (::XSCRT::XML::Element<char> const& element)
    :Base (element)
    {

      ::XSCRT::Parser<char> p (element);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<char> e (p.next_element ());
        std::string n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "name")
        {
          name_ = std::make_unique<::XMLSchema::string<char>> (e);
        }

        else if (n == "resourceType")
        {
          ::XMLSchema::string<char> t (e);
          resourceType_.push_back (t);
        }

        else if (n == "property")
        {
          ::DAnCE::Config_Handlers::SatisfierProperty t (e);
          property_.push_back (t);
        }

        else
        {
        }
      }
    }

    // Requirement

    Requirement::
    Requirement (::XSCRT::XML::Element<char> const& element)
    :Base (element)
    {

      ::XSCRT::Parser<char> p (element);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<char> e (p.next_element ());
        std::string n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "name")
        {
          name_ = std::make_unique<::XMLSchema::string<char>> (e);
        }

        else if (n == "resourceType")
        {
          resourceType_ = std::make_unique<::XMLSchema::string<char>> (e);
        }

        else if (n == "property")
        {
          ::DAnCE::Config_Handlers::Property t (e);
          property_.push_back (t);
        }

        else
        {
        }
      }
    }

    // ResourceDeploymentDescription

    ResourceDeploymentDescription::
    ResourceDeploymentDescription (::XSCRT::XML::Element<char> const& element)
    :Base (element)
    {

      ::XSCRT::Parser<char> p (element);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<char> e (p.next_element ());
        std::string n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "requirementName")
        {
          requirementName_ = std::make_unique<::XMLSchema::string<char>> (e);
        }

        else if (n == "resourceName")
        {
          resourceName_ = std::make_unique<::XMLSchema::string<char>> (e);
        }

        else if (n == "property")
        {
          ::DAnCE::Config_Handlers::Property t (e);
          property_.push_back (t);
        }

        else
        {
        }
      }
    }

    // ArtifactDeploymentDescription

    ArtifactDeploymentDescription::
    ArtifactDeploymentDescription (::XSCRT::XML::Element<char> const& element)
    :Base (element)
    {

      ::XSCRT::Parser<char> p (element);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<char> e (p.next_element ());
        std::string n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "name")
        {
          name_ = std::make_unique<::XMLSchema::string<char>> (e);
        }

        else if (n == "source")
        {
          ::XMLSchema::string<char> t (e);
          source_.push_back (t);
        }

        else if (n == "node")
        {
          node_ = std::make_unique<::XMLSchema::string<char>> (e);
        }

        else if (n == "location")
        {
          ::XMLSchema::string<char> t (e);
          location_.push_back (t);
        }

        else if (n == "execParameter")
        {
          ::DAnCE::Config_Handlers::Property t (e);
          execParameter_.push_back (t);
        }

        else if (n == "deployRequirement")
        {
          ::DAnCE::Config_Handlers::Requirement t (e);
          deployRequirement_.push_back (t);
        }

        else if (n == "deployedResource")
        {
          ::DAnCE::Config_Handlers::ResourceDeploymentDescription t (e);
          deployedResource_.push_back (t);
        }

        else
        {
        }
      }

      while (p.more_attributes ())
      {
        ::XSCRT::XML::Attribute<char> a (p.next_attribute ());
        std::string n (::XSCRT::XML::uq_name (a.name ()));
        if (n ==  ("id"))
        {
          ::XMLSchema::ID<char> t (a);
          id (t);
        }

        else
        {
        }
      }
    }

    // MonolithicDeploymentDescription

    MonolithicDeploymentDescription::
    MonolithicDeploymentDescription (::XSCRT::XML::Element<char> const& element)
    :Base (element)
    {

      ::XSCRT::Parser<char> p (element);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<char> e (p.next_element ());
        std::string n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "name")
        {
          name_ = std::make_unique<::XMLSchema::string<char>> (e);
        }

        else if (n == "source")
        {
          ::XMLSchema::string<char> t (e);
          source_.push_back (t);
        }

        else if (n == "artifact")
        {
          ::DAnCE::Config_Handlers::IdRef t (e);
          artifact_.push_back (t);
        }

        else if (n == "execParameter")
        {
          ::DAnCE::Config_Handlers::Property t (e);
          execParameter_.push_back (t);
        }

        else if (n == "deployRequirement")
        {
          ::DAnCE::Config_Handlers::Requirement t (e);
          deployRequirement_.push_back (t);
        }

        else
        {
        }
      }

      while (p.more_attributes ())
      {
        ::XSCRT::XML::Attribute<char> a (p.next_attribute ());
        std::string n (::XSCRT::XML::uq_name (a.name ()));
        if (n ==  ("id"))
        {
          ::XMLSchema::ID<char> t (a);
          id (t);
        }

        else
        {
        }
      }
    }

    // ResourceUsageKind

    ResourceUsageKind::
    ResourceUsageKind (::XSCRT::XML::Element<char> const& e)
    : ::XSCRT::Type (e)
    {
      std::string v (e.value ());

      if (v ==  ("None")) v_ = None_l;
      else if (v ==  ("InstanceUsesResource")) v_ = InstanceUsesResource_l;
      else if (v ==  ("ResourceUsesInstance")) v_ = ResourceUsesInstance_l;
      else if (v ==  ("PortUsesResource")) v_ = PortUsesResource_l;
      else if (v ==  ("ResourceUsesPort")) v_ = ResourceUsesPort_l;
      else
      {
      }
    }

    ResourceUsageKind::
    ResourceUsageKind (::XSCRT::XML::Attribute<char> const& a)
    : ::XSCRT::Type (a)
    {
      std::string v (a.value ());

      if (v ==  ("None")) v_ = None_l;
      else if (v ==  ("InstanceUsesResource")) v_ = InstanceUsesResource_l;
      else if (v ==  ("ResourceUsesInstance")) v_ = ResourceUsesInstance_l;
      else if (v ==  ("PortUsesResource")) v_ = PortUsesResource_l;
      else if (v ==  ("ResourceUsesPort")) v_ = ResourceUsesPort_l;
      else
      {
      }
    }

    ResourceUsageKind const ResourceUsageKind::None (ResourceUsageKind::None_l);
    ResourceUsageKind const ResourceUsageKind::InstanceUsesResource (ResourceUsageKind::InstanceUsesResource_l);
    ResourceUsageKind const ResourceUsageKind::ResourceUsesInstance (ResourceUsageKind::ResourceUsesInstance_l);
    ResourceUsageKind const ResourceUsageKind::PortUsesResource (ResourceUsageKind::PortUsesResource_l);
    ResourceUsageKind const ResourceUsageKind::ResourceUsesPort (ResourceUsageKind::ResourceUsesPort_l);

    // InstanceResourceDeploymentDescription

    InstanceResourceDeploymentDescription::
    InstanceResourceDeploymentDescription (::XSCRT::XML::Element<char> const& element)
    :Base (element)
    {

      ::XSCRT::Parser<char> p (element);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<char> e (p.next_element ());
        std::string n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "resourceUsage")
        {
          resourceUsage_ = std::make_unique<::DAnCE::Config_Handlers::ResourceUsageKind> (e);
        }

        else if (n == "requirementName")
        {
          requirementName_ = std::make_unique<::XMLSchema::string<char>> (e);
        }

        else if (n == "resourceName")
        {
          resourceName_ = std::make_unique<::XMLSchema::string<char>> (e);
        }

        else if (n == "property")
        {
          ::DAnCE::Config_Handlers::Property t (e);
          property_.push_back (t);
        }

        else
        {
        }
      }
    }

    // InstanceDeploymentDescription

    InstanceDeploymentDescription::
    InstanceDeploymentDescription (::XSCRT::XML::Element<char> const& element)
    :Base (element)
    {

      ::XSCRT::Parser<char> p (element);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<char> e (p.next_element ());
        std::string n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "name")
        {
          name_ = std::make_unique<::XMLSchema::string<char>> (e);
        }

        else if (n == "node")
        {
          node_ = std::make_unique<::XMLSchema::string<char>> (e);
        }

        else if (n == "source")
        {
          source_ = std::make_unique<::XMLSchema::string<char>> (e);
        }

        else if (n == "implementation")
        {
          implementation_ = std::make_unique<::DAnCE::Config_Handlers::IdRef> (e);
        }

        else if (n == "configProperty")
        {
          ::DAnCE::Config_Handlers::Property t (e);
          configProperty_.push_back (t);
        }

        else if (n == "deployedResource")
        {
          ::DAnCE::Config_Handlers::InstanceResourceDeploymentDescription t (e);
          deployedResource_.push_back (t);
        }

        else if (n == "deployedSharedResource")
        {
          ::DAnCE::Config_Handlers::InstanceResourceDeploymentDescription t (e);
          deployedSharedResource_.push_back (t);
        }

        else
        {
        }
      }

      while (p.more_attributes ())
      {
        ::XSCRT::XML::Attribute<char> a (p.next_attribute ());
        std::string n (::XSCRT::XML::uq_name (a.name ()));
        if (n ==  ("id"))
        {
          ::XMLSchema::ID<char> t (a);
          id (t);
        }

        else
        {
        }
      }
    }

    // CCMComponentPortKind

    CCMComponentPortKind::
    CCMComponentPortKind (::XSCRT::XML::Element<char> const& e)
    : ::XSCRT::Type (e)
    {
      std::string v (e.value ());

      if (v ==  ("Facet")) v_ = Facet_l;
      else if (v ==  ("SimplexReceptacle")) v_ = SimplexReceptacle_l;
      else if (v ==  ("MultiplexReceptacle")) v_ = MultiplexReceptacle_l;
      else if (v ==  ("EventEmitter")) v_ = EventEmitter_l;
      else if (v ==  ("EventPublisher")) v_ = EventPublisher_l;
      else if (v ==  ("EventConsumer")) v_ = EventConsumer_l;
      else if (v ==  ("ExtendedPort")) v_ = ExtendedPort_l;
      else if (v ==  ("MirrorPort")) v_ = MirrorPort_l;
      else
      {
      }
    }

    CCMComponentPortKind::
    CCMComponentPortKind (::XSCRT::XML::Attribute<char> const& a)
    : ::XSCRT::Type (a)
    {
      std::string v (a.value ());

      if (v ==  ("Facet")) v_ = Facet_l;
      else if (v ==  ("SimplexReceptacle")) v_ = SimplexReceptacle_l;
      else if (v ==  ("MultiplexReceptacle")) v_ = MultiplexReceptacle_l;
      else if (v ==  ("EventEmitter")) v_ = EventEmitter_l;
      else if (v ==  ("EventPublisher")) v_ = EventPublisher_l;
      else if (v ==  ("EventConsumer")) v_ = EventConsumer_l;
      else if (v ==  ("ExtendedPort")) v_ = ExtendedPort_l;
      else if (v ==  ("MirrorPort")) v_ = MirrorPort_l;
      else
      {
      }
    }

    CCMComponentPortKind const CCMComponentPortKind::Facet (CCMComponentPortKind::Facet_l);
    CCMComponentPortKind const CCMComponentPortKind::SimplexReceptacle (CCMComponentPortKind::SimplexReceptacle_l);
    CCMComponentPortKind const CCMComponentPortKind::MultiplexReceptacle (CCMComponentPortKind::MultiplexReceptacle_l);
    CCMComponentPortKind const CCMComponentPortKind::EventEmitter (CCMComponentPortKind::EventEmitter_l);
    CCMComponentPortKind const CCMComponentPortKind::EventPublisher (CCMComponentPortKind::EventPublisher_l);
    CCMComponentPortKind const CCMComponentPortKind::EventConsumer (CCMComponentPortKind::EventConsumer_l);
    CCMComponentPortKind const CCMComponentPortKind::ExtendedPort (CCMComponentPortKind::ExtendedPort_l);
    CCMComponentPortKind const CCMComponentPortKind::MirrorPort (CCMComponentPortKind::MirrorPort_l);

    // ComponentPortDescription

    ComponentPortDescription::
    ComponentPortDescription (::XSCRT::XML::Element<char> const& element)
    :Base (element)
    {

      ::XSCRT::Parser<char> p (element);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<char> e (p.next_element ());
        std::string n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "name")
        {
          name_ = std::make_unique<::XMLSchema::string<char>> (e);
        }

        else if (n == "specificType")
        {
          ::XMLSchema::string<char> t (e);
          specificType (t);
        }

        else if (n == "supportedType")
        {
          ::XMLSchema::string<char> t (e);
          supportedType_.push_back (t);
        }

        else if (n == "provider")
        {
          provider_ = std::make_unique<::XMLSchema::boolean> (e);
        }

        else if (n == "exclusiveProvider")
        {
          exclusiveProvider_ = std::make_unique<::XMLSchema::boolean> (e);
        }

        else if (n == "exclusiveUser")
        {
          exclusiveUser_ = std::make_unique<::XMLSchema::boolean> (e);
        }

        else if (n == "optional")
        {
          optional_ = std::make_unique<::XMLSchema::boolean> (e);
        }

        else if (n == "kind")
        {
          kind_ = std::make_unique<::DAnCE::Config_Handlers::CCMComponentPortKind> (e);
        }

        else if (n == "templateParam")
        {
          ::XMLSchema::string<char> t (e);
          templateParam_.push_back (t);
        }

        else
        {
        }
      }
    }

    // ComponentPropertyDescription

    ComponentPropertyDescription::
    ComponentPropertyDescription (::XSCRT::XML::Element<char> const& element)
    :Base (element)
    {

      ::XSCRT::Parser<char> p (element);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<char> e (p.next_element ());
        std::string n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "name")
        {
          name_ = std::make_unique<::XMLSchema::string<char>> (e);
        }

        else if (n == "type")
        {
          type_ = std::make_unique<::DAnCE::Config_Handlers::DataType> (e);
        }

        else
        {
        }
      }
    }

    // ComponentExternalPortEndpoint

    ComponentExternalPortEndpoint::
    ComponentExternalPortEndpoint (::XSCRT::XML::Element<char> const& element)
    :Base (element)
    {

      ::XSCRT::Parser<char> p (element);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<char> e (p.next_element ());
        std::string n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "portName")
        {
          portName_ = std::make_unique<::XMLSchema::string<char>> (e);
        }

        else
        {
        }
      }
    }

    // PlanSubcomponentPortEndpoint

    PlanSubcomponentPortEndpoint::
    PlanSubcomponentPortEndpoint (::XSCRT::XML::Element<char> const& element)
    :Base (element)
    {

      ::XSCRT::Parser<char> p (element);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<char> e (p.next_element ());
        std::string n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "portName")
        {
          portName_ = std::make_unique<::XMLSchema::string<char>> (e);
        }

        else if (n == "provider")
        {
          ::XMLSchema::string<char> t (e);
          provider (t);
        }

        else if (n == "kind")
        {
          kind_ = std::make_unique<::DAnCE::Config_Handlers::CCMComponentPortKind> (e);
        }

        else if (n == "instance")
        {
          instance_ = std::make_unique<::DAnCE::Config_Handlers::IdRef> (e);
        }

        else
        {
        }
      }
    }

    // ExternalReferenceEndpoint

    ExternalReferenceEndpoint::
    ExternalReferenceEndpoint (::XSCRT::XML::Element<char> const& element)
    :Base (element)
    {

      ::XSCRT::Parser<char> p (element);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<char> e (p.next_element ());
        std::string n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "location")
        {
          location_ = std::make_unique<::XMLSchema::string<char>> (e);
        }

        else if (n == "provider")
        {
          provider_ = std::make_unique<::XMLSchema::boolean> (e);
        }

        else if (n == "portName")
        {
          ::XMLSchema::string<char> t (e);
          portName (t);
        }

        else if (n == "supportedType")
        {
          ::XMLSchema::string<char> t (e);
          supportedType_.push_back (t);
        }

        else
        {
        }
      }
    }

    // ConnectionResourceDeploymentDescription

    ConnectionResourceDeploymentDescription::
    ConnectionResourceDeploymentDescription (::XSCRT::XML::Element<char> const& element)
    :Base (element)
    {

      ::XSCRT::Parser<char> p (element);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<char> e (p.next_element ());
        std::string n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "targetName")
        {
          targetName_ = std::make_unique<::XMLSchema::string<char>> (e);
        }

        else if (n == "requirementName")
        {
          requirementName_ = std::make_unique<::XMLSchema::string<char>> (e);
        }

        else if (n == "resourceName")
        {
          resourceName_ = std::make_unique<::XMLSchema::string<char>> (e);
        }

        else if (n == "property")
        {
          ::DAnCE::Config_Handlers::Property t (e);
          property_.push_back (t);
        }

        else
        {
        }
      }
    }

    // PlanConnectionDescription

    PlanConnectionDescription::
    PlanConnectionDescription (::XSCRT::XML::Element<char> const& element)
    :Base (element)
    {

      ::XSCRT::Parser<char> p (element);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<char> e (p.next_element ());
        std::string n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "name")
        {
          name_ = std::make_unique<::XMLSchema::string<char>> (e);
        }

        else if (n == "source")
        {
          ::XMLSchema::string<char> t (e);
          source (t);
        }

        else if (n == "deployRequirement")
        {
          ::DAnCE::Config_Handlers::Requirement t (e);
          deployRequirement_.push_back (t);
        }

        else if (n == "externalEndpoint")
        {
          ::DAnCE::Config_Handlers::ComponentExternalPortEndpoint t (e);
          externalEndpoint_.push_back (t);
        }

        else if (n == "internalEndpoint")
        {
          ::DAnCE::Config_Handlers::PlanSubcomponentPortEndpoint t (e);
          internalEndpoint_.push_back (t);
        }

        else if (n == "externalReference")
        {
          ::DAnCE::Config_Handlers::ExternalReferenceEndpoint t (e);
          externalReference_.push_back (t);
        }

        else if (n == "deployedResource")
        {
          ::DAnCE::Config_Handlers::ConnectionResourceDeploymentDescription t (e);
          deployedResource_.push_back (t);
        }

        else
        {
        }
      }
    }

    // ImplementationDependency

    ImplementationDependency::
    ImplementationDependency (::XSCRT::XML::Element<char> const& element)
    :Base (element)
    {

      ::XSCRT::Parser<char> p (element);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<char> e (p.next_element ());
        std::string n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "requiredType")
        {
          requiredType_ = std::make_unique<::XMLSchema::string<char>> (e);
        }

        else
        {
        }
      }
    }

    // Capability

    Capability::
    Capability (::XSCRT::XML::Element<char> const& element)
    :Base (element)
    {

      ::XSCRT::Parser<char> p (element);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<char> e (p.next_element ());
        std::string n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "name")
        {
          name_ = std::make_unique<::XMLSchema::string<char>> (e);
        }

        else if (n == "resourceType")
        {
          ::XMLSchema::string<char> t (e);
          resourceType_.push_back (t);
        }

        else if (n == "property")
        {
          ::DAnCE::Config_Handlers::SatisfierProperty t (e);
          property_.push_back (t);
        }

        else
        {
        }
      }
    }

    // ImplementationRequirement

    ImplementationRequirement::
    ImplementationRequirement (::XSCRT::XML::Element<char> const& element)
    :Base (element)
    {

      ::XSCRT::Parser<char> p (element);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<char> e (p.next_element ());
        std::string n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "resourceUsage")
        {
          ::DAnCE::Config_Handlers::ResourceUsageKind t (e);
          resourceUsage (t);
        }

        else if (n == "resourcePort")
        {
          ::XMLSchema::string<char> t (e);
          resourcePort (t);
        }

        else if (n == "componentPort")
        {
          ::XMLSchema::string<char> t (e);
          componentPort (t);
        }

        else if (n == "resourceType")
        {
          resourceType_ = std::make_unique<::XMLSchema::string<char>> (e);
        }

        else if (n == "name")
        {
          name_ = std::make_unique<::XMLSchema::string<char>> (e);
        }

        else if (n == "property")
        {
          ::DAnCE::Config_Handlers::Property t (e);
          property_.push_back (t);
        }

        else
        {
        }
      }
    }

    // SubcomponentPortEndpoint

    SubcomponentPortEndpoint::
    SubcomponentPortEndpoint (::XSCRT::XML::Element<char> const& element)
    :Base (element)
    {

      ::XSCRT::Parser<char> p (element);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<char> e (p.next_element ());
        std::string n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "portName")
        {
          portName_ = std::make_unique<::XMLSchema::string<char>> (e);
        }

        else if (n == "instance")
        {
          instance_ = std::make_unique<::DAnCE::Config_Handlers::IdRef> (e);
        }

        else
        {
        }
      }
    }

    // AssemblyConnectionDescription

    AssemblyConnectionDescription::
    AssemblyConnectionDescription (::XSCRT::XML::Element<char> const& element)
    :Base (element)
    {

      ::XSCRT::Parser<char> p (element);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<char> e (p.next_element ());
        std::string n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "name")
        {
          name_ = std::make_unique<::XMLSchema::string<char>> (e);
        }

        else if (n == "deployRequirement")
        {
          ::DAnCE::Config_Handlers::Requirement t (e);
          deployRequirement_.push_back (t);
        }

        else if (n == "internalEndpoint")
        {
          ::DAnCE::Config_Handlers::SubcomponentPortEndpoint t (e);
          internalEndpoint_.push_back (t);
        }

        else if (n == "externalEndpoint")
        {
          ::DAnCE::Config_Handlers::ComponentExternalPortEndpoint t (e);
          externalEndpoint_.push_back (t);
        }

        else if (n == "externalReference")
        {
          ::DAnCE::Config_Handlers::ExternalReferenceEndpoint t (e);
          externalReference_.push_back (t);
        }

        else
        {
        }
      }
    }

    // PlanLocalityKind

    PlanLocalityKind::
    PlanLocalityKind (::XSCRT::XML::Element<char> const& e)
    : ::XSCRT::Type (e)
    {
      std::string v (e.value ());

      if (v ==  ("SameProcess")) v_ = SameProcess_l;
      else if (v ==  ("DifferentProcess")) v_ = DifferentProcess_l;
      else if (v ==  ("NoConstraint")) v_ = NoConstraint_l;
      else
      {
      }
    }

    PlanLocalityKind::
    PlanLocalityKind (::XSCRT::XML::Attribute<char> const& a)
    : ::XSCRT::Type (a)
    {
      std::string v (a.value ());

      if (v ==  ("SameProcess")) v_ = SameProcess_l;
      else if (v ==  ("DifferentProcess")) v_ = DifferentProcess_l;
      else if (v ==  ("NoConstraint")) v_ = NoConstraint_l;
      else
      {
      }
    }

    PlanLocalityKind const PlanLocalityKind::SameProcess (PlanLocalityKind::SameProcess_l);
    PlanLocalityKind const PlanLocalityKind::DifferentProcess (PlanLocalityKind::DifferentProcess_l);
    PlanLocalityKind const PlanLocalityKind::NoConstraint (PlanLocalityKind::NoConstraint_l);

    // PlanLocality

    PlanLocality::
    PlanLocality (::XSCRT::XML::Element<char> const& element)
    :Base (element)
    {

      ::XSCRT::Parser<char> p (element);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<char> e (p.next_element ());
        std::string n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "constraint")
        {
          constraint_ = std::make_unique<::DAnCE::Config_Handlers::PlanLocalityKind> (e);
        }

        else if (n == "constrainedInstance")
        {
          ::DAnCE::Config_Handlers::IdRef t (e);
          constrainedInstance_.push_back (t);
        }

        else
        {
        }
      }
    }
  }
}

namespace DAnCE
{
  namespace Config_Handlers
  {
  }
}

